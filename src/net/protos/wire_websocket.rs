// This file is generated by rust-protobuf 2.10.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `wire_websocket.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_0;

#[derive(PartialEq,Clone,Default)]
pub struct GenericMessage {
    // message fields
    message_id: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub content: ::std::option::Option<GenericMessage_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenericMessage {
    fn default() -> &'a GenericMessage {
        <GenericMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GenericMessage_oneof_content {
    text(Text),
    image(ImageAsset),
    knock(Knock),
    lastRead(LastRead),
    cleared(Cleared),
    external(External),
    clientAction(ClientAction),
    calling(Calling),
    asset(Asset),
    hidden(MessageHide),
    location(Location),
    deleted(MessageDelete),
    edited(MessageEdit),
    confirmation(Confirmation),
    reaction(Reaction),
    ephemeral(Ephemeral),
    availability(Availability),
}

impl GenericMessage {
    pub fn new() -> GenericMessage {
        ::std::default::Default::default()
    }

    // required string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        match self.message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        self.message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Text text = 2;


    pub fn get_text(&self) -> &Text {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::text(ref v)) => v,
            _ => Text::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Text) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut Text {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::text(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::text(Text::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> Text {
        if self.has_text() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::text(v)) => v,
                _ => panic!(),
            }
        } else {
            Text::new()
        }
    }

    // optional .ImageAsset image = 3;


    pub fn get_image(&self) -> &ImageAsset {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::image(ref v)) => v,
            _ => ImageAsset::default_instance(),
        }
    }
    pub fn clear_image(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageAsset) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut ImageAsset {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::image(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::image(ImageAsset::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> ImageAsset {
        if self.has_image() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::image(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageAsset::new()
        }
    }

    // optional .Knock knock = 4;


    pub fn get_knock(&self) -> &Knock {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::knock(ref v)) => v,
            _ => Knock::default_instance(),
        }
    }
    pub fn clear_knock(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_knock(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::knock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_knock(&mut self, v: Knock) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::knock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_knock(&mut self) -> &mut Knock {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::knock(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::knock(Knock::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::knock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_knock(&mut self) -> Knock {
        if self.has_knock() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::knock(v)) => v,
                _ => panic!(),
            }
        } else {
            Knock::new()
        }
    }

    // optional .LastRead lastRead = 6;


    pub fn get_lastRead(&self) -> &LastRead {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(ref v)) => v,
            _ => LastRead::default_instance(),
        }
    }
    pub fn clear_lastRead(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_lastRead(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_lastRead(&mut self, v: LastRead) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(v))
    }

    // Mutable pointer to the field.
    pub fn mut_lastRead(&mut self) -> &mut LastRead {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(LastRead::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_lastRead(&mut self) -> LastRead {
        if self.has_lastRead() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(v)) => v,
                _ => panic!(),
            }
        } else {
            LastRead::new()
        }
    }

    // optional .Cleared cleared = 7;


    pub fn get_cleared(&self) -> &Cleared {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::cleared(ref v)) => v,
            _ => Cleared::default_instance(),
        }
    }
    pub fn clear_cleared(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_cleared(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::cleared(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cleared(&mut self, v: Cleared) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::cleared(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cleared(&mut self) -> &mut Cleared {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::cleared(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::cleared(Cleared::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::cleared(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cleared(&mut self) -> Cleared {
        if self.has_cleared() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::cleared(v)) => v,
                _ => panic!(),
            }
        } else {
            Cleared::new()
        }
    }

    // optional .External external = 8;


    pub fn get_external(&self) -> &External {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::external(ref v)) => v,
            _ => External::default_instance(),
        }
    }
    pub fn clear_external(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_external(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::external(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_external(&mut self, v: External) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::external(v))
    }

    // Mutable pointer to the field.
    pub fn mut_external(&mut self) -> &mut External {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::external(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::external(External::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::external(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_external(&mut self) -> External {
        if self.has_external() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::external(v)) => v,
                _ => panic!(),
            }
        } else {
            External::new()
        }
    }

    // optional .ClientAction clientAction = 9;


    pub fn get_clientAction(&self) -> ClientAction {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::clientAction(v)) => v,
            _ => ClientAction::RESET_SESSION,
        }
    }
    pub fn clear_clientAction(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_clientAction(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::clientAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clientAction(&mut self, v: ClientAction) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::clientAction(v))
    }

    // optional .Calling calling = 10;


    pub fn get_calling(&self) -> &Calling {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::calling(ref v)) => v,
            _ => Calling::default_instance(),
        }
    }
    pub fn clear_calling(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_calling(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::calling(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_calling(&mut self, v: Calling) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::calling(v))
    }

    // Mutable pointer to the field.
    pub fn mut_calling(&mut self) -> &mut Calling {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::calling(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::calling(Calling::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::calling(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_calling(&mut self) -> Calling {
        if self.has_calling() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::calling(v)) => v,
                _ => panic!(),
            }
        } else {
            Calling::new()
        }
    }

    // optional .Asset asset = 11;


    pub fn get_asset(&self) -> &Asset {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::asset(ref v)) => v,
            _ => Asset::default_instance(),
        }
    }
    pub fn clear_asset(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_asset(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::asset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: Asset) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::asset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut Asset {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::asset(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::asset(Asset::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::asset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_asset(&mut self) -> Asset {
        if self.has_asset() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::asset(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset::new()
        }
    }

    // optional .MessageHide hidden = 12;


    pub fn get_hidden(&self) -> &MessageHide {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::hidden(ref v)) => v,
            _ => MessageHide::default_instance(),
        }
    }
    pub fn clear_hidden(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::hidden(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: MessageHide) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::hidden(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hidden(&mut self) -> &mut MessageHide {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::hidden(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::hidden(MessageHide::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::hidden(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hidden(&mut self) -> MessageHide {
        if self.has_hidden() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::hidden(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageHide::new()
        }
    }

    // optional .Location location = 13;


    pub fn get_location(&self) -> &Location {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::location(ref v)) => v,
            _ => Location::default_instance(),
        }
    }
    pub fn clear_location(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::location(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::location(v))
    }

    // Mutable pointer to the field.
    pub fn mut_location(&mut self) -> &mut Location {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::location(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::location(Location::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::location(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        if self.has_location() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::location(v)) => v,
                _ => panic!(),
            }
        } else {
            Location::new()
        }
    }

    // optional .MessageDelete deleted = 14;


    pub fn get_deleted(&self) -> &MessageDelete {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::deleted(ref v)) => v,
            _ => MessageDelete::default_instance(),
        }
    }
    pub fn clear_deleted(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::deleted(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: MessageDelete) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::deleted(v))
    }

    // Mutable pointer to the field.
    pub fn mut_deleted(&mut self) -> &mut MessageDelete {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::deleted(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::deleted(MessageDelete::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::deleted(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_deleted(&mut self) -> MessageDelete {
        if self.has_deleted() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::deleted(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageDelete::new()
        }
    }

    // optional .MessageEdit edited = 15;


    pub fn get_edited(&self) -> &MessageEdit {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::edited(ref v)) => v,
            _ => MessageEdit::default_instance(),
        }
    }
    pub fn clear_edited(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_edited(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::edited(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_edited(&mut self, v: MessageEdit) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::edited(v))
    }

    // Mutable pointer to the field.
    pub fn mut_edited(&mut self) -> &mut MessageEdit {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::edited(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::edited(MessageEdit::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::edited(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_edited(&mut self) -> MessageEdit {
        if self.has_edited() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::edited(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageEdit::new()
        }
    }

    // optional .Confirmation confirmation = 16;


    pub fn get_confirmation(&self) -> &Confirmation {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(ref v)) => v,
            _ => Confirmation::default_instance(),
        }
    }
    pub fn clear_confirmation(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_confirmation(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confirmation(&mut self, v: Confirmation) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confirmation(&mut self) -> &mut Confirmation {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(Confirmation::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confirmation(&mut self) -> Confirmation {
        if self.has_confirmation() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            Confirmation::new()
        }
    }

    // optional .Reaction reaction = 17;


    pub fn get_reaction(&self) -> &Reaction {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::reaction(ref v)) => v,
            _ => Reaction::default_instance(),
        }
    }
    pub fn clear_reaction(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::reaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: Reaction) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::reaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reaction(&mut self) -> &mut Reaction {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::reaction(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::reaction(Reaction::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::reaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reaction(&mut self) -> Reaction {
        if self.has_reaction() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::reaction(v)) => v,
                _ => panic!(),
            }
        } else {
            Reaction::new()
        }
    }

    // optional .Ephemeral ephemeral = 18;


    pub fn get_ephemeral(&self) -> &Ephemeral {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(ref v)) => v,
            _ => Ephemeral::default_instance(),
        }
    }
    pub fn clear_ephemeral(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_ephemeral(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: Ephemeral) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeral(&mut self) -> &mut Ephemeral {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(Ephemeral::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> Ephemeral {
        if self.has_ephemeral() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(v)) => v,
                _ => panic!(),
            }
        } else {
            Ephemeral::new()
        }
    }

    // optional .Availability availability = 19;


    pub fn get_availability(&self) -> &Availability {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::availability(ref v)) => v,
            _ => Availability::default_instance(),
        }
    }
    pub fn clear_availability(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_availability(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::availability(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_availability(&mut self, v: Availability) {
        self.content = ::std::option::Option::Some(GenericMessage_oneof_content::availability(v))
    }

    // Mutable pointer to the field.
    pub fn mut_availability(&mut self) -> &mut Availability {
        if let ::std::option::Option::Some(GenericMessage_oneof_content::availability(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(GenericMessage_oneof_content::availability(Availability::new()));
        }
        match self.content {
            ::std::option::Option::Some(GenericMessage_oneof_content::availability(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_availability(&mut self) -> Availability {
        if self.has_availability() {
            match self.content.take() {
                ::std::option::Option::Some(GenericMessage_oneof_content::availability(v)) => v,
                _ => panic!(),
            }
        } else {
            Availability::new()
        }
    }
}

impl ::protobuf::Message for GenericMessage {
    fn is_initialized(&self) -> bool {
        if self.message_id.is_none() {
            return false;
        }
        if let Some(GenericMessage_oneof_content::text(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::image(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::knock(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::lastRead(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::cleared(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::external(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::calling(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::asset(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::hidden(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::location(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::deleted(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::edited(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::confirmation(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::reaction(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::ephemeral(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GenericMessage_oneof_content::availability(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::text(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::image(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::knock(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::lastRead(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::cleared(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::external(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::clientAction(is.read_enum()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::calling(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::asset(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::hidden(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::location(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::deleted(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::edited(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::confirmation(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::reaction(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::ephemeral(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(GenericMessage_oneof_content::availability(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &GenericMessage_oneof_content::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::image(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::knock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::lastRead(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::cleared(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::external(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::clientAction(v) => {
                    my_size += ::protobuf::rt::enum_size(9, v);
                },
                &GenericMessage_oneof_content::calling(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::asset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::hidden(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::location(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::deleted(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::edited(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::confirmation(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::reaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::ephemeral(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GenericMessage_oneof_content::availability(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &GenericMessage_oneof_content::text(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::image(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::knock(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::lastRead(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::cleared(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::external(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::clientAction(v) => {
                    os.write_enum(9, v.value())?;
                },
                &GenericMessage_oneof_content::calling(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::asset(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::hidden(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::location(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::deleted(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::edited(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::confirmation(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::reaction(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::ephemeral(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GenericMessage_oneof_content::availability(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenericMessage {
        GenericMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &GenericMessage| { &m.message_id },
                    |m: &mut GenericMessage| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Text>(
                    "text",
                    GenericMessage::has_text,
                    GenericMessage::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImageAsset>(
                    "image",
                    GenericMessage::has_image,
                    GenericMessage::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Knock>(
                    "knock",
                    GenericMessage::has_knock,
                    GenericMessage::get_knock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LastRead>(
                    "lastRead",
                    GenericMessage::has_lastRead,
                    GenericMessage::get_lastRead,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Cleared>(
                    "cleared",
                    GenericMessage::has_cleared,
                    GenericMessage::get_cleared,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, External>(
                    "external",
                    GenericMessage::has_external,
                    GenericMessage::get_external,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ClientAction>(
                    "clientAction",
                    GenericMessage::has_clientAction,
                    GenericMessage::get_clientAction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Calling>(
                    "calling",
                    GenericMessage::has_calling,
                    GenericMessage::get_calling,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset>(
                    "asset",
                    GenericMessage::has_asset,
                    GenericMessage::get_asset,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageHide>(
                    "hidden",
                    GenericMessage::has_hidden,
                    GenericMessage::get_hidden,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Location>(
                    "location",
                    GenericMessage::has_location,
                    GenericMessage::get_location,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageDelete>(
                    "deleted",
                    GenericMessage::has_deleted,
                    GenericMessage::get_deleted,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageEdit>(
                    "edited",
                    GenericMessage::has_edited,
                    GenericMessage::get_edited,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Confirmation>(
                    "confirmation",
                    GenericMessage::has_confirmation,
                    GenericMessage::get_confirmation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reaction>(
                    "reaction",
                    GenericMessage::has_reaction,
                    GenericMessage::get_reaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ephemeral>(
                    "ephemeral",
                    GenericMessage::has_ephemeral,
                    GenericMessage::get_ephemeral,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Availability>(
                    "availability",
                    GenericMessage::has_availability,
                    GenericMessage::get_availability,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenericMessage>(
                    "GenericMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenericMessage {
        static mut instance: ::protobuf::lazy::Lazy<GenericMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenericMessage,
        };
        unsafe {
            instance.get(GenericMessage::new)
        }
    }
}

impl ::protobuf::Clear for GenericMessage {
    fn clear(&mut self) {
        self.message_id.clear();
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenericMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenericMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Availability {
    // message fields
    field_type: ::std::option::Option<Availability_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Availability {
    fn default() -> &'a Availability {
        <Availability as ::protobuf::Message>::default_instance()
    }
}

impl Availability {
    pub fn new() -> Availability {
        ::std::default::Default::default()
    }

    // required .Availability.Type type = 1;


    pub fn get_field_type(&self) -> Availability_Type {
        self.field_type.unwrap_or(Availability_Type::NONE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Availability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Availability {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Availability {
        Availability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Availability_Type>>(
                    "type",
                    |m: &Availability| { &m.field_type },
                    |m: &mut Availability| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Availability>(
                    "Availability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Availability {
        static mut instance: ::protobuf::lazy::Lazy<Availability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Availability,
        };
        unsafe {
            instance.get(Availability::new)
        }
    }
}

impl ::protobuf::Clear for Availability {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Availability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Availability_Type {
    NONE = 0,
    AVAILABLE = 1,
    AWAY = 2,
    BUSY = 3,
}

impl ::protobuf::ProtobufEnum for Availability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Availability_Type> {
        match value {
            0 => ::std::option::Option::Some(Availability_Type::NONE),
            1 => ::std::option::Option::Some(Availability_Type::AVAILABLE),
            2 => ::std::option::Option::Some(Availability_Type::AWAY),
            3 => ::std::option::Option::Some(Availability_Type::BUSY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Availability_Type] = &[
            Availability_Type::NONE,
            Availability_Type::AVAILABLE,
            Availability_Type::AWAY,
            Availability_Type::BUSY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Availability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Availability_Type {
}

impl ::std::default::Default for Availability_Type {
    fn default() -> Self {
        Availability_Type::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Availability_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ephemeral {
    // message fields
    expire_after_millis: ::std::option::Option<i64>,
    // message oneof groups
    pub content: ::std::option::Option<Ephemeral_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ephemeral {
    fn default() -> &'a Ephemeral {
        <Ephemeral as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Ephemeral_oneof_content {
    text(Text),
    image(ImageAsset),
    knock(Knock),
    asset(Asset),
    location(Location),
}

impl Ephemeral {
    pub fn new() -> Ephemeral {
        ::std::default::Default::default()
    }

    // required int64 expire_after_millis = 1;


    pub fn get_expire_after_millis(&self) -> i64 {
        self.expire_after_millis.unwrap_or(0)
    }
    pub fn clear_expire_after_millis(&mut self) {
        self.expire_after_millis = ::std::option::Option::None;
    }

    pub fn has_expire_after_millis(&self) -> bool {
        self.expire_after_millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_after_millis(&mut self, v: i64) {
        self.expire_after_millis = ::std::option::Option::Some(v);
    }

    // optional .Text text = 2;


    pub fn get_text(&self) -> &Text {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::text(ref v)) => v,
            _ => Text::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Text) {
        self.content = ::std::option::Option::Some(Ephemeral_oneof_content::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut Text {
        if let ::std::option::Option::Some(Ephemeral_oneof_content::text(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Ephemeral_oneof_content::text(Text::new()));
        }
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> Text {
        if self.has_text() {
            match self.content.take() {
                ::std::option::Option::Some(Ephemeral_oneof_content::text(v)) => v,
                _ => panic!(),
            }
        } else {
            Text::new()
        }
    }

    // optional .ImageAsset image = 3;


    pub fn get_image(&self) -> &ImageAsset {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::image(ref v)) => v,
            _ => ImageAsset::default_instance(),
        }
    }
    pub fn clear_image(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ImageAsset) {
        self.content = ::std::option::Option::Some(Ephemeral_oneof_content::image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut ImageAsset {
        if let ::std::option::Option::Some(Ephemeral_oneof_content::image(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Ephemeral_oneof_content::image(ImageAsset::new()));
        }
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> ImageAsset {
        if self.has_image() {
            match self.content.take() {
                ::std::option::Option::Some(Ephemeral_oneof_content::image(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageAsset::new()
        }
    }

    // optional .Knock knock = 4;


    pub fn get_knock(&self) -> &Knock {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::knock(ref v)) => v,
            _ => Knock::default_instance(),
        }
    }
    pub fn clear_knock(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_knock(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::knock(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_knock(&mut self, v: Knock) {
        self.content = ::std::option::Option::Some(Ephemeral_oneof_content::knock(v))
    }

    // Mutable pointer to the field.
    pub fn mut_knock(&mut self) -> &mut Knock {
        if let ::std::option::Option::Some(Ephemeral_oneof_content::knock(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Ephemeral_oneof_content::knock(Knock::new()));
        }
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::knock(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_knock(&mut self) -> Knock {
        if self.has_knock() {
            match self.content.take() {
                ::std::option::Option::Some(Ephemeral_oneof_content::knock(v)) => v,
                _ => panic!(),
            }
        } else {
            Knock::new()
        }
    }

    // optional .Asset asset = 5;


    pub fn get_asset(&self) -> &Asset {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::asset(ref v)) => v,
            _ => Asset::default_instance(),
        }
    }
    pub fn clear_asset(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_asset(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::asset(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: Asset) {
        self.content = ::std::option::Option::Some(Ephemeral_oneof_content::asset(v))
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut Asset {
        if let ::std::option::Option::Some(Ephemeral_oneof_content::asset(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Ephemeral_oneof_content::asset(Asset::new()));
        }
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::asset(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_asset(&mut self) -> Asset {
        if self.has_asset() {
            match self.content.take() {
                ::std::option::Option::Some(Ephemeral_oneof_content::asset(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset::new()
        }
    }

    // optional .Location location = 6;


    pub fn get_location(&self) -> &Location {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::location(ref v)) => v,
            _ => Location::default_instance(),
        }
    }
    pub fn clear_location(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::location(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.content = ::std::option::Option::Some(Ephemeral_oneof_content::location(v))
    }

    // Mutable pointer to the field.
    pub fn mut_location(&mut self) -> &mut Location {
        if let ::std::option::Option::Some(Ephemeral_oneof_content::location(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(Ephemeral_oneof_content::location(Location::new()));
        }
        match self.content {
            ::std::option::Option::Some(Ephemeral_oneof_content::location(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        if self.has_location() {
            match self.content.take() {
                ::std::option::Option::Some(Ephemeral_oneof_content::location(v)) => v,
                _ => panic!(),
            }
        } else {
            Location::new()
        }
    }
}

impl ::protobuf::Message for Ephemeral {
    fn is_initialized(&self) -> bool {
        if self.expire_after_millis.is_none() {
            return false;
        }
        if let Some(Ephemeral_oneof_content::text(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Ephemeral_oneof_content::image(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Ephemeral_oneof_content::knock(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Ephemeral_oneof_content::asset(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Ephemeral_oneof_content::location(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_after_millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Ephemeral_oneof_content::text(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Ephemeral_oneof_content::image(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Ephemeral_oneof_content::knock(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Ephemeral_oneof_content::asset(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(Ephemeral_oneof_content::location(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.expire_after_millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Ephemeral_oneof_content::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Ephemeral_oneof_content::image(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Ephemeral_oneof_content::knock(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Ephemeral_oneof_content::asset(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Ephemeral_oneof_content::location(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.expire_after_millis {
            os.write_int64(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &Ephemeral_oneof_content::text(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Ephemeral_oneof_content::image(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Ephemeral_oneof_content::knock(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Ephemeral_oneof_content::asset(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Ephemeral_oneof_content::location(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ephemeral {
        Ephemeral::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expire_after_millis",
                    |m: &Ephemeral| { &m.expire_after_millis },
                    |m: &mut Ephemeral| { &mut m.expire_after_millis },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Text>(
                    "text",
                    Ephemeral::has_text,
                    Ephemeral::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImageAsset>(
                    "image",
                    Ephemeral::has_image,
                    Ephemeral::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Knock>(
                    "knock",
                    Ephemeral::has_knock,
                    Ephemeral::get_knock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset>(
                    "asset",
                    Ephemeral::has_asset,
                    Ephemeral::get_asset,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Location>(
                    "location",
                    Ephemeral::has_location,
                    Ephemeral::get_location,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ephemeral>(
                    "Ephemeral",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ephemeral {
        static mut instance: ::protobuf::lazy::Lazy<Ephemeral> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ephemeral,
        };
        unsafe {
            instance.get(Ephemeral::new)
        }
    }
}

impl ::protobuf::Clear for Ephemeral {
    fn clear(&mut self) {
        self.expire_after_millis = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ephemeral {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ephemeral {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Text {
    // message fields
    content: ::protobuf::SingularField<::std::string::String>,
    link_preview: ::protobuf::RepeatedField<LinkPreview>,
    mentions: ::protobuf::RepeatedField<Mention>,
    quote: ::protobuf::SingularPtrField<Quote>,
    expects_read_confirmation: ::std::option::Option<bool>,
    legal_hold_status: ::std::option::Option<LegalHoldStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Text {
    fn default() -> &'a Text {
        <Text as ::protobuf::Message>::default_instance()
    }
}

impl Text {
    pub fn new() -> Text {
        ::std::default::Default::default()
    }

    // required string content = 1;


    pub fn get_content(&self) -> &str {
        match self.content.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        self.content.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .LinkPreview link_preview = 3;


    pub fn get_link_preview(&self) -> &[LinkPreview] {
        &self.link_preview
    }
    pub fn clear_link_preview(&mut self) {
        self.link_preview.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_preview(&mut self, v: ::protobuf::RepeatedField<LinkPreview>) {
        self.link_preview = v;
    }

    // Mutable pointer to the field.
    pub fn mut_link_preview(&mut self) -> &mut ::protobuf::RepeatedField<LinkPreview> {
        &mut self.link_preview
    }

    // Take field
    pub fn take_link_preview(&mut self) -> ::protobuf::RepeatedField<LinkPreview> {
        ::std::mem::replace(&mut self.link_preview, ::protobuf::RepeatedField::new())
    }

    // repeated .Mention mentions = 4;


    pub fn get_mentions(&self) -> &[Mention] {
        &self.mentions
    }
    pub fn clear_mentions(&mut self) {
        self.mentions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mentions(&mut self, v: ::protobuf::RepeatedField<Mention>) {
        self.mentions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mentions(&mut self) -> &mut ::protobuf::RepeatedField<Mention> {
        &mut self.mentions
    }

    // Take field
    pub fn take_mentions(&mut self) -> ::protobuf::RepeatedField<Mention> {
        ::std::mem::replace(&mut self.mentions, ::protobuf::RepeatedField::new())
    }

    // optional .Quote quote = 5;


    pub fn get_quote(&self) -> &Quote {
        self.quote.as_ref().unwrap_or_else(|| Quote::default_instance())
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: Quote) {
        self.quote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut Quote {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> Quote {
        self.quote.take().unwrap_or_else(|| Quote::new())
    }

    // optional bool expects_read_confirmation = 6;


    pub fn get_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.unwrap_or(false)
    }
    pub fn clear_expects_read_confirmation(&mut self) {
        self.expects_read_confirmation = ::std::option::Option::None;
    }

    pub fn has_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expects_read_confirmation(&mut self, v: bool) {
        self.expects_read_confirmation = ::std::option::Option::Some(v);
    }

    // optional .LegalHoldStatus legal_hold_status = 7;


    pub fn get_legal_hold_status(&self) -> LegalHoldStatus {
        self.legal_hold_status.unwrap_or(LegalHoldStatus::UNKNOWN)
    }
    pub fn clear_legal_hold_status(&mut self) {
        self.legal_hold_status = ::std::option::Option::None;
    }

    pub fn has_legal_hold_status(&self) -> bool {
        self.legal_hold_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legal_hold_status(&mut self, v: LegalHoldStatus) {
        self.legal_hold_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Text {
    fn is_initialized(&self) -> bool {
        if self.content.is_none() {
            return false;
        }
        for v in &self.link_preview {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mentions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quote {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.content)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.link_preview)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mentions)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quote)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expects_read_confirmation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.legal_hold_status, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.link_preview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.mentions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.quote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.expects_read_confirmation {
            my_size += 2;
        }
        if let Some(v) = self.legal_hold_status {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.content.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.link_preview {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.mentions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.quote.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.expects_read_confirmation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.legal_hold_status {
            os.write_enum(7, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Text {
        Text::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &Text| { &m.content },
                    |m: &mut Text| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinkPreview>>(
                    "link_preview",
                    |m: &Text| { &m.link_preview },
                    |m: &mut Text| { &mut m.link_preview },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Mention>>(
                    "mentions",
                    |m: &Text| { &m.mentions },
                    |m: &mut Text| { &mut m.mentions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quote>>(
                    "quote",
                    |m: &Text| { &m.quote },
                    |m: &mut Text| { &mut m.quote },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "expects_read_confirmation",
                    |m: &Text| { &m.expects_read_confirmation },
                    |m: &mut Text| { &mut m.expects_read_confirmation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegalHoldStatus>>(
                    "legal_hold_status",
                    |m: &Text| { &m.legal_hold_status },
                    |m: &mut Text| { &mut m.legal_hold_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Text>(
                    "Text",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Text {
        static mut instance: ::protobuf::lazy::Lazy<Text> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Text,
        };
        unsafe {
            instance.get(Text::new)
        }
    }
}

impl ::protobuf::Clear for Text {
    fn clear(&mut self) {
        self.content.clear();
        self.link_preview.clear();
        self.mentions.clear();
        self.quote.clear();
        self.expects_read_confirmation = ::std::option::Option::None;
        self.legal_hold_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Text {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Knock {
    // message fields
    hot_knock: ::std::option::Option<bool>,
    expects_read_confirmation: ::std::option::Option<bool>,
    legal_hold_status: ::std::option::Option<LegalHoldStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Knock {
    fn default() -> &'a Knock {
        <Knock as ::protobuf::Message>::default_instance()
    }
}

impl Knock {
    pub fn new() -> Knock {
        ::std::default::Default::default()
    }

    // required bool hot_knock = 1;


    pub fn get_hot_knock(&self) -> bool {
        self.hot_knock.unwrap_or(false)
    }
    pub fn clear_hot_knock(&mut self) {
        self.hot_knock = ::std::option::Option::None;
    }

    pub fn has_hot_knock(&self) -> bool {
        self.hot_knock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_knock(&mut self, v: bool) {
        self.hot_knock = ::std::option::Option::Some(v);
    }

    // optional bool expects_read_confirmation = 2;


    pub fn get_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.unwrap_or(false)
    }
    pub fn clear_expects_read_confirmation(&mut self) {
        self.expects_read_confirmation = ::std::option::Option::None;
    }

    pub fn has_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expects_read_confirmation(&mut self, v: bool) {
        self.expects_read_confirmation = ::std::option::Option::Some(v);
    }

    // optional .LegalHoldStatus legal_hold_status = 3;


    pub fn get_legal_hold_status(&self) -> LegalHoldStatus {
        self.legal_hold_status.unwrap_or(LegalHoldStatus::UNKNOWN)
    }
    pub fn clear_legal_hold_status(&mut self) {
        self.legal_hold_status = ::std::option::Option::None;
    }

    pub fn has_legal_hold_status(&self) -> bool {
        self.legal_hold_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legal_hold_status(&mut self, v: LegalHoldStatus) {
        self.legal_hold_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Knock {
    fn is_initialized(&self) -> bool {
        if self.hot_knock.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hot_knock = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expects_read_confirmation = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.legal_hold_status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hot_knock {
            my_size += 2;
        }
        if let Some(v) = self.expects_read_confirmation {
            my_size += 2;
        }
        if let Some(v) = self.legal_hold_status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hot_knock {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.expects_read_confirmation {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.legal_hold_status {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Knock {
        Knock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hot_knock",
                    |m: &Knock| { &m.hot_knock },
                    |m: &mut Knock| { &mut m.hot_knock },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "expects_read_confirmation",
                    |m: &Knock| { &m.expects_read_confirmation },
                    |m: &mut Knock| { &mut m.expects_read_confirmation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegalHoldStatus>>(
                    "legal_hold_status",
                    |m: &Knock| { &m.legal_hold_status },
                    |m: &mut Knock| { &mut m.legal_hold_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Knock>(
                    "Knock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Knock {
        static mut instance: ::protobuf::lazy::Lazy<Knock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Knock,
        };
        unsafe {
            instance.get(Knock::new)
        }
    }
}

impl ::protobuf::Clear for Knock {
    fn clear(&mut self) {
        self.hot_knock = ::std::option::Option::None;
        self.expects_read_confirmation = ::std::option::Option::None;
        self.legal_hold_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Knock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Knock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkPreview {
    // message fields
    url: ::protobuf::SingularField<::std::string::String>,
    url_offset: ::std::option::Option<i32>,
    permanent_url: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    summary: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularPtrField<Asset>,
    // message oneof groups
    pub preview: ::std::option::Option<LinkPreview_oneof_preview>,
    pub meta_data: ::std::option::Option<LinkPreview_oneof_meta_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinkPreview {
    fn default() -> &'a LinkPreview {
        <LinkPreview as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinkPreview_oneof_preview {
    article(Article),
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinkPreview_oneof_meta_data {
    tweet(Tweet),
}

impl LinkPreview {
    pub fn new() -> LinkPreview {
        ::std::default::Default::default()
    }

    // required string url = 1;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 url_offset = 2;


    pub fn get_url_offset(&self) -> i32 {
        self.url_offset.unwrap_or(0)
    }
    pub fn clear_url_offset(&mut self) {
        self.url_offset = ::std::option::Option::None;
    }

    pub fn has_url_offset(&self) -> bool {
        self.url_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url_offset(&mut self, v: i32) {
        self.url_offset = ::std::option::Option::Some(v);
    }

    // optional .Article article = 3;


    pub fn get_article(&self) -> &Article {
        match self.preview {
            ::std::option::Option::Some(LinkPreview_oneof_preview::article(ref v)) => v,
            _ => Article::default_instance(),
        }
    }
    pub fn clear_article(&mut self) {
        self.preview = ::std::option::Option::None;
    }

    pub fn has_article(&self) -> bool {
        match self.preview {
            ::std::option::Option::Some(LinkPreview_oneof_preview::article(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_article(&mut self, v: Article) {
        self.preview = ::std::option::Option::Some(LinkPreview_oneof_preview::article(v))
    }

    // Mutable pointer to the field.
    pub fn mut_article(&mut self) -> &mut Article {
        if let ::std::option::Option::Some(LinkPreview_oneof_preview::article(_)) = self.preview {
        } else {
            self.preview = ::std::option::Option::Some(LinkPreview_oneof_preview::article(Article::new()));
        }
        match self.preview {
            ::std::option::Option::Some(LinkPreview_oneof_preview::article(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_article(&mut self) -> Article {
        if self.has_article() {
            match self.preview.take() {
                ::std::option::Option::Some(LinkPreview_oneof_preview::article(v)) => v,
                _ => panic!(),
            }
        } else {
            Article::new()
        }
    }

    // optional string permanent_url = 5;


    pub fn get_permanent_url(&self) -> &str {
        match self.permanent_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_permanent_url(&mut self) {
        self.permanent_url.clear();
    }

    pub fn has_permanent_url(&self) -> bool {
        self.permanent_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent_url(&mut self, v: ::std::string::String) {
        self.permanent_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permanent_url(&mut self) -> &mut ::std::string::String {
        if self.permanent_url.is_none() {
            self.permanent_url.set_default();
        }
        self.permanent_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_permanent_url(&mut self) -> ::std::string::String {
        self.permanent_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 6;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 7;


    pub fn get_summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Asset image = 8;


    pub fn get_image(&self) -> &Asset {
        self.image.as_ref().unwrap_or_else(|| Asset::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Asset) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Asset {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Asset {
        self.image.take().unwrap_or_else(|| Asset::new())
    }

    // optional .Tweet tweet = 9;


    pub fn get_tweet(&self) -> &Tweet {
        match self.meta_data {
            ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(ref v)) => v,
            _ => Tweet::default_instance(),
        }
    }
    pub fn clear_tweet(&mut self) {
        self.meta_data = ::std::option::Option::None;
    }

    pub fn has_tweet(&self) -> bool {
        match self.meta_data {
            ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tweet(&mut self, v: Tweet) {
        self.meta_data = ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tweet(&mut self) -> &mut Tweet {
        if let ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(_)) = self.meta_data {
        } else {
            self.meta_data = ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(Tweet::new()));
        }
        match self.meta_data {
            ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tweet(&mut self) -> Tweet {
        if self.has_tweet() {
            match self.meta_data.take() {
                ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(v)) => v,
                _ => panic!(),
            }
        } else {
            Tweet::new()
        }
    }
}

impl ::protobuf::Message for LinkPreview {
    fn is_initialized(&self) -> bool {
        if self.url.is_none() {
            return false;
        }
        if self.url_offset.is_none() {
            return false;
        }
        if let Some(LinkPreview_oneof_preview::article(ref v)) = self.preview {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(LinkPreview_oneof_meta_data::tweet(ref v)) = self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.url_offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.preview = ::std::option::Option::Some(LinkPreview_oneof_preview::article(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permanent_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.summary)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data = ::std::option::Option::Some(LinkPreview_oneof_meta_data::tweet(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url_offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.permanent_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.preview {
            match v {
                &LinkPreview_oneof_preview::article(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &LinkPreview_oneof_meta_data::tweet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.url_offset {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.permanent_url.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.summary.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.preview {
            match v {
                &LinkPreview_oneof_preview::article(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &LinkPreview_oneof_meta_data::tweet(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkPreview {
        LinkPreview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &LinkPreview| { &m.url },
                    |m: &mut LinkPreview| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "url_offset",
                    |m: &LinkPreview| { &m.url_offset },
                    |m: &mut LinkPreview| { &mut m.url_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Article>(
                    "article",
                    LinkPreview::has_article,
                    LinkPreview::get_article,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permanent_url",
                    |m: &LinkPreview| { &m.permanent_url },
                    |m: &mut LinkPreview| { &mut m.permanent_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &LinkPreview| { &m.title },
                    |m: &mut LinkPreview| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "summary",
                    |m: &LinkPreview| { &m.summary },
                    |m: &mut LinkPreview| { &mut m.summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asset>>(
                    "image",
                    |m: &LinkPreview| { &m.image },
                    |m: &mut LinkPreview| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Tweet>(
                    "tweet",
                    LinkPreview::has_tweet,
                    LinkPreview::get_tweet,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LinkPreview>(
                    "LinkPreview",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinkPreview {
        static mut instance: ::protobuf::lazy::Lazy<LinkPreview> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LinkPreview,
        };
        unsafe {
            instance.get(LinkPreview::new)
        }
    }
}

impl ::protobuf::Clear for LinkPreview {
    fn clear(&mut self) {
        self.url.clear();
        self.url_offset = ::std::option::Option::None;
        self.preview = ::std::option::Option::None;
        self.permanent_url.clear();
        self.title.clear();
        self.summary.clear();
        self.image.clear();
        self.meta_data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkPreview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkPreview {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tweet {
    // message fields
    author: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tweet {
    fn default() -> &'a Tweet {
        <Tweet as ::protobuf::Message>::default_instance()
    }
}

impl Tweet {
    pub fn new() -> Tweet {
        ::std::default::Default::default()
    }

    // optional string author = 1;


    pub fn get_author(&self) -> &str {
        match self.author.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_author(&mut self) {
        self.author.clear();
    }

    pub fn has_author(&self) -> bool {
        self.author.is_some()
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: ::std::string::String) {
        self.author = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_author(&mut self) -> &mut ::std::string::String {
        if self.author.is_none() {
            self.author.set_default();
        }
        self.author.as_mut().unwrap()
    }

    // Take field
    pub fn take_author(&mut self) -> ::std::string::String {
        self.author.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string username = 2;


    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Tweet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.author)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.author.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.author.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tweet {
        Tweet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "author",
                    |m: &Tweet| { &m.author },
                    |m: &mut Tweet| { &mut m.author },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &Tweet| { &m.username },
                    |m: &mut Tweet| { &mut m.username },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tweet>(
                    "Tweet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Tweet {
        static mut instance: ::protobuf::lazy::Lazy<Tweet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Tweet,
        };
        unsafe {
            instance.get(Tweet::new)
        }
    }
}

impl ::protobuf::Clear for Tweet {
    fn clear(&mut self) {
        self.author.clear();
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tweet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tweet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Article {
    // message fields
    permanent_url: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    summary: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularPtrField<Asset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Article {
    fn default() -> &'a Article {
        <Article as ::protobuf::Message>::default_instance()
    }
}

impl Article {
    pub fn new() -> Article {
        ::std::default::Default::default()
    }

    // required string permanent_url = 1;


    pub fn get_permanent_url(&self) -> &str {
        match self.permanent_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_permanent_url(&mut self) {
        self.permanent_url.clear();
    }

    pub fn has_permanent_url(&self) -> bool {
        self.permanent_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent_url(&mut self, v: ::std::string::String) {
        self.permanent_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permanent_url(&mut self) -> &mut ::std::string::String {
        if self.permanent_url.is_none() {
            self.permanent_url.set_default();
        }
        self.permanent_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_permanent_url(&mut self) -> ::std::string::String {
        self.permanent_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 3;


    pub fn get_summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Asset image = 4;


    pub fn get_image(&self) -> &Asset {
        self.image.as_ref().unwrap_or_else(|| Asset::default_instance())
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Asset) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut Asset {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Asset {
        self.image.take().unwrap_or_else(|| Asset::new())
    }
}

impl ::protobuf::Message for Article {
    fn is_initialized(&self) -> bool {
        if self.permanent_url.is_none() {
            return false;
        }
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.permanent_url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.summary)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.permanent_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.permanent_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.summary.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Article {
        Article::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "permanent_url",
                    |m: &Article| { &m.permanent_url },
                    |m: &mut Article| { &mut m.permanent_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &Article| { &m.title },
                    |m: &mut Article| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "summary",
                    |m: &Article| { &m.summary },
                    |m: &mut Article| { &mut m.summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asset>>(
                    "image",
                    |m: &Article| { &m.image },
                    |m: &mut Article| { &mut m.image },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Article>(
                    "Article",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Article {
        static mut instance: ::protobuf::lazy::Lazy<Article> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Article,
        };
        unsafe {
            instance.get(Article::new)
        }
    }
}

impl ::protobuf::Clear for Article {
    fn clear(&mut self) {
        self.permanent_url.clear();
        self.title.clear();
        self.summary.clear();
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Article {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Article {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mention {
    // message fields
    start: ::std::option::Option<i32>,
    length: ::std::option::Option<i32>,
    // message oneof groups
    pub mention_type: ::std::option::Option<Mention_oneof_mention_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mention {
    fn default() -> &'a Mention {
        <Mention as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Mention_oneof_mention_type {
    user_id(::std::string::String),
}

impl Mention {
    pub fn new() -> Mention {
        ::std::default::Default::default()
    }

    // required int32 start = 1;


    pub fn get_start(&self) -> i32 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // required int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional string user_id = 3;


    pub fn get_user_id(&self) -> &str {
        match self.mention_type {
            ::std::option::Option::Some(Mention_oneof_mention_type::user_id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_user_id(&mut self) {
        self.mention_type = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        match self.mention_type {
            ::std::option::Option::Some(Mention_oneof_mention_type::user_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.mention_type = ::std::option::Option::Some(Mention_oneof_mention_type::user_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Mention_oneof_mention_type::user_id(_)) = self.mention_type {
        } else {
            self.mention_type = ::std::option::Option::Some(Mention_oneof_mention_type::user_id(::std::string::String::new()));
        }
        match self.mention_type {
            ::std::option::Option::Some(Mention_oneof_mention_type::user_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        if self.has_user_id() {
            match self.mention_type.take() {
                ::std::option::Option::Some(Mention_oneof_mention_type::user_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for Mention {
    fn is_initialized(&self) -> bool {
        if self.start.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mention_type = ::std::option::Option::Some(Mention_oneof_mention_type::user_id(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.mention_type {
            match v {
                &Mention_oneof_mention_type::user_id(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.mention_type {
            match v {
                &Mention_oneof_mention_type::user_id(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mention {
        Mention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "start",
                    |m: &Mention| { &m.start },
                    |m: &mut Mention| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "length",
                    |m: &Mention| { &m.length },
                    |m: &mut Mention| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "user_id",
                    Mention::has_user_id,
                    Mention::get_user_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Mention>(
                    "Mention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Mention {
        static mut instance: ::protobuf::lazy::Lazy<Mention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Mention,
        };
        unsafe {
            instance.get(Mention::new)
        }
    }
}

impl ::protobuf::Clear for Mention {
    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.mention_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LastRead {
    // message fields
    conversation_id: ::protobuf::SingularField<::std::string::String>,
    last_read_timestamp: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LastRead {
    fn default() -> &'a LastRead {
        <LastRead as ::protobuf::Message>::default_instance()
    }
}

impl LastRead {
    pub fn new() -> LastRead {
        ::std::default::Default::default()
    }

    // required string conversation_id = 1;


    pub fn get_conversation_id(&self) -> &str {
        match self.conversation_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_conversation_id(&mut self) {
        self.conversation_id.clear();
    }

    pub fn has_conversation_id(&self) -> bool {
        self.conversation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversation_id(&mut self, v: ::std::string::String) {
        self.conversation_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation_id(&mut self) -> &mut ::std::string::String {
        if self.conversation_id.is_none() {
            self.conversation_id.set_default();
        }
        self.conversation_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversation_id(&mut self) -> ::std::string::String {
        self.conversation_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 last_read_timestamp = 2;


    pub fn get_last_read_timestamp(&self) -> i64 {
        self.last_read_timestamp.unwrap_or(0)
    }
    pub fn clear_last_read_timestamp(&mut self) {
        self.last_read_timestamp = ::std::option::Option::None;
    }

    pub fn has_last_read_timestamp(&self) -> bool {
        self.last_read_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_read_timestamp(&mut self, v: i64) {
        self.last_read_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LastRead {
    fn is_initialized(&self) -> bool {
        if self.conversation_id.is_none() {
            return false;
        }
        if self.last_read_timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.conversation_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_read_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conversation_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.last_read_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conversation_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.last_read_timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LastRead {
        LastRead::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "conversation_id",
                    |m: &LastRead| { &m.conversation_id },
                    |m: &mut LastRead| { &mut m.conversation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_read_timestamp",
                    |m: &LastRead| { &m.last_read_timestamp },
                    |m: &mut LastRead| { &mut m.last_read_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LastRead>(
                    "LastRead",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LastRead {
        static mut instance: ::protobuf::lazy::Lazy<LastRead> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LastRead,
        };
        unsafe {
            instance.get(LastRead::new)
        }
    }
}

impl ::protobuf::Clear for LastRead {
    fn clear(&mut self) {
        self.conversation_id.clear();
        self.last_read_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LastRead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LastRead {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cleared {
    // message fields
    conversation_id: ::protobuf::SingularField<::std::string::String>,
    cleared_timestamp: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cleared {
    fn default() -> &'a Cleared {
        <Cleared as ::protobuf::Message>::default_instance()
    }
}

impl Cleared {
    pub fn new() -> Cleared {
        ::std::default::Default::default()
    }

    // required string conversation_id = 1;


    pub fn get_conversation_id(&self) -> &str {
        match self.conversation_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_conversation_id(&mut self) {
        self.conversation_id.clear();
    }

    pub fn has_conversation_id(&self) -> bool {
        self.conversation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversation_id(&mut self, v: ::std::string::String) {
        self.conversation_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation_id(&mut self) -> &mut ::std::string::String {
        if self.conversation_id.is_none() {
            self.conversation_id.set_default();
        }
        self.conversation_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversation_id(&mut self) -> ::std::string::String {
        self.conversation_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 cleared_timestamp = 2;


    pub fn get_cleared_timestamp(&self) -> i64 {
        self.cleared_timestamp.unwrap_or(0)
    }
    pub fn clear_cleared_timestamp(&mut self) {
        self.cleared_timestamp = ::std::option::Option::None;
    }

    pub fn has_cleared_timestamp(&self) -> bool {
        self.cleared_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cleared_timestamp(&mut self, v: i64) {
        self.cleared_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Cleared {
    fn is_initialized(&self) -> bool {
        if self.conversation_id.is_none() {
            return false;
        }
        if self.cleared_timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.conversation_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cleared_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conversation_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cleared_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conversation_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.cleared_timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cleared {
        Cleared::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "conversation_id",
                    |m: &Cleared| { &m.conversation_id },
                    |m: &mut Cleared| { &mut m.conversation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cleared_timestamp",
                    |m: &Cleared| { &m.cleared_timestamp },
                    |m: &mut Cleared| { &mut m.cleared_timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cleared>(
                    "Cleared",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cleared {
        static mut instance: ::protobuf::lazy::Lazy<Cleared> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cleared,
        };
        unsafe {
            instance.get(Cleared::new)
        }
    }
}

impl ::protobuf::Clear for Cleared {
    fn clear(&mut self) {
        self.conversation_id.clear();
        self.cleared_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cleared {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cleared {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageHide {
    // message fields
    conversation_id: ::protobuf::SingularField<::std::string::String>,
    message_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageHide {
    fn default() -> &'a MessageHide {
        <MessageHide as ::protobuf::Message>::default_instance()
    }
}

impl MessageHide {
    pub fn new() -> MessageHide {
        ::std::default::Default::default()
    }

    // required string conversation_id = 1;


    pub fn get_conversation_id(&self) -> &str {
        match self.conversation_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_conversation_id(&mut self) {
        self.conversation_id.clear();
    }

    pub fn has_conversation_id(&self) -> bool {
        self.conversation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversation_id(&mut self, v: ::std::string::String) {
        self.conversation_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation_id(&mut self) -> &mut ::std::string::String {
        if self.conversation_id.is_none() {
            self.conversation_id.set_default();
        }
        self.conversation_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversation_id(&mut self) -> ::std::string::String {
        self.conversation_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string message_id = 2;


    pub fn get_message_id(&self) -> &str {
        match self.message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        self.message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageHide {
    fn is_initialized(&self) -> bool {
        if self.conversation_id.is_none() {
            return false;
        }
        if self.message_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.conversation_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conversation_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conversation_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageHide {
        MessageHide::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "conversation_id",
                    |m: &MessageHide| { &m.conversation_id },
                    |m: &mut MessageHide| { &mut m.conversation_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &MessageHide| { &m.message_id },
                    |m: &mut MessageHide| { &mut m.message_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageHide>(
                    "MessageHide",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageHide {
        static mut instance: ::protobuf::lazy::Lazy<MessageHide> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageHide,
        };
        unsafe {
            instance.get(MessageHide::new)
        }
    }
}

impl ::protobuf::Clear for MessageHide {
    fn clear(&mut self) {
        self.conversation_id.clear();
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageHide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageHide {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageDelete {
    // message fields
    message_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageDelete {
    fn default() -> &'a MessageDelete {
        <MessageDelete as ::protobuf::Message>::default_instance()
    }
}

impl MessageDelete {
    pub fn new() -> MessageDelete {
        ::std::default::Default::default()
    }

    // required string message_id = 1;


    pub fn get_message_id(&self) -> &str {
        match self.message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        self.message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageDelete {
    fn is_initialized(&self) -> bool {
        if self.message_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageDelete {
        MessageDelete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &MessageDelete| { &m.message_id },
                    |m: &mut MessageDelete| { &mut m.message_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageDelete>(
                    "MessageDelete",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageDelete {
        static mut instance: ::protobuf::lazy::Lazy<MessageDelete> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageDelete,
        };
        unsafe {
            instance.get(MessageDelete::new)
        }
    }
}

impl ::protobuf::Clear for MessageDelete {
    fn clear(&mut self) {
        self.message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageDelete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageDelete {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageEdit {
    // message fields
    replacing_message_id: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub content: ::std::option::Option<MessageEdit_oneof_content>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageEdit {
    fn default() -> &'a MessageEdit {
        <MessageEdit as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MessageEdit_oneof_content {
    text(Text),
}

impl MessageEdit {
    pub fn new() -> MessageEdit {
        ::std::default::Default::default()
    }

    // required string replacing_message_id = 1;


    pub fn get_replacing_message_id(&self) -> &str {
        match self.replacing_message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_replacing_message_id(&mut self) {
        self.replacing_message_id.clear();
    }

    pub fn has_replacing_message_id(&self) -> bool {
        self.replacing_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replacing_message_id(&mut self, v: ::std::string::String) {
        self.replacing_message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replacing_message_id(&mut self) -> &mut ::std::string::String {
        if self.replacing_message_id.is_none() {
            self.replacing_message_id.set_default();
        }
        self.replacing_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_replacing_message_id(&mut self) -> ::std::string::String {
        self.replacing_message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Text text = 2;


    pub fn get_text(&self) -> &Text {
        match self.content {
            ::std::option::Option::Some(MessageEdit_oneof_content::text(ref v)) => v,
            _ => Text::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(MessageEdit_oneof_content::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Text) {
        self.content = ::std::option::Option::Some(MessageEdit_oneof_content::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut Text {
        if let ::std::option::Option::Some(MessageEdit_oneof_content::text(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(MessageEdit_oneof_content::text(Text::new()));
        }
        match self.content {
            ::std::option::Option::Some(MessageEdit_oneof_content::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> Text {
        if self.has_text() {
            match self.content.take() {
                ::std::option::Option::Some(MessageEdit_oneof_content::text(v)) => v,
                _ => panic!(),
            }
        } else {
            Text::new()
        }
    }
}

impl ::protobuf::Message for MessageEdit {
    fn is_initialized(&self) -> bool {
        if self.replacing_message_id.is_none() {
            return false;
        }
        if let Some(MessageEdit_oneof_content::text(ref v)) = self.content {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replacing_message_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.content = ::std::option::Option::Some(MessageEdit_oneof_content::text(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.replacing_message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &MessageEdit_oneof_content::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.replacing_message_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &MessageEdit_oneof_content::text(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageEdit {
        MessageEdit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "replacing_message_id",
                    |m: &MessageEdit| { &m.replacing_message_id },
                    |m: &mut MessageEdit| { &mut m.replacing_message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Text>(
                    "text",
                    MessageEdit::has_text,
                    MessageEdit::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageEdit>(
                    "MessageEdit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageEdit {
        static mut instance: ::protobuf::lazy::Lazy<MessageEdit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageEdit,
        };
        unsafe {
            instance.get(MessageEdit::new)
        }
    }
}

impl ::protobuf::Clear for MessageEdit {
    fn clear(&mut self) {
        self.replacing_message_id.clear();
        self.content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageEdit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageEdit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Quote {
    // message fields
    quoted_message_id: ::protobuf::SingularField<::std::string::String>,
    quoted_message_sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Quote {
    fn default() -> &'a Quote {
        <Quote as ::protobuf::Message>::default_instance()
    }
}

impl Quote {
    pub fn new() -> Quote {
        ::std::default::Default::default()
    }

    // required string quoted_message_id = 1;


    pub fn get_quoted_message_id(&self) -> &str {
        match self.quoted_message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_quoted_message_id(&mut self) {
        self.quoted_message_id.clear();
    }

    pub fn has_quoted_message_id(&self) -> bool {
        self.quoted_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quoted_message_id(&mut self, v: ::std::string::String) {
        self.quoted_message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quoted_message_id(&mut self) -> &mut ::std::string::String {
        if self.quoted_message_id.is_none() {
            self.quoted_message_id.set_default();
        }
        self.quoted_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_quoted_message_id(&mut self) -> ::std::string::String {
        self.quoted_message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes quoted_message_sha256 = 2;


    pub fn get_quoted_message_sha256(&self) -> &[u8] {
        match self.quoted_message_sha256.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_quoted_message_sha256(&mut self) {
        self.quoted_message_sha256.clear();
    }

    pub fn has_quoted_message_sha256(&self) -> bool {
        self.quoted_message_sha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quoted_message_sha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.quoted_message_sha256 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quoted_message_sha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.quoted_message_sha256.is_none() {
            self.quoted_message_sha256.set_default();
        }
        self.quoted_message_sha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_quoted_message_sha256(&mut self) -> ::std::vec::Vec<u8> {
        self.quoted_message_sha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Quote {
    fn is_initialized(&self) -> bool {
        if self.quoted_message_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.quoted_message_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.quoted_message_sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quoted_message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.quoted_message_sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quoted_message_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.quoted_message_sha256.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quote {
        Quote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "quoted_message_id",
                    |m: &Quote| { &m.quoted_message_id },
                    |m: &mut Quote| { &mut m.quoted_message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "quoted_message_sha256",
                    |m: &Quote| { &m.quoted_message_sha256 },
                    |m: &mut Quote| { &mut m.quoted_message_sha256 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Quote>(
                    "Quote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Quote {
        static mut instance: ::protobuf::lazy::Lazy<Quote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Quote,
        };
        unsafe {
            instance.get(Quote::new)
        }
    }
}

impl ::protobuf::Clear for Quote {
    fn clear(&mut self) {
        self.quoted_message_id.clear();
        self.quoted_message_sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Confirmation {
    // message fields
    field_type: ::std::option::Option<Confirmation_Type>,
    first_message_id: ::protobuf::SingularField<::std::string::String>,
    more_message_ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Confirmation {
    fn default() -> &'a Confirmation {
        <Confirmation as ::protobuf::Message>::default_instance()
    }
}

impl Confirmation {
    pub fn new() -> Confirmation {
        ::std::default::Default::default()
    }

    // required .Confirmation.Type type = 2;


    pub fn get_field_type(&self) -> Confirmation_Type {
        self.field_type.unwrap_or(Confirmation_Type::DELIVERED)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Confirmation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required string first_message_id = 1;


    pub fn get_first_message_id(&self) -> &str {
        match self.first_message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_first_message_id(&mut self) {
        self.first_message_id.clear();
    }

    pub fn has_first_message_id(&self) -> bool {
        self.first_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_message_id(&mut self, v: ::std::string::String) {
        self.first_message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_message_id(&mut self) -> &mut ::std::string::String {
        if self.first_message_id.is_none() {
            self.first_message_id.set_default();
        }
        self.first_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_message_id(&mut self) -> ::std::string::String {
        self.first_message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string more_message_ids = 3;


    pub fn get_more_message_ids(&self) -> &[::std::string::String] {
        &self.more_message_ids
    }
    pub fn clear_more_message_ids(&mut self) {
        self.more_message_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_more_message_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.more_message_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_more_message_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.more_message_ids
    }

    // Take field
    pub fn take_more_message_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.more_message_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Confirmation {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.first_message_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.first_message_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.more_message_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.first_message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.more_message_ids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.first_message_id.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.more_message_ids {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Confirmation {
        Confirmation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Confirmation_Type>>(
                    "type",
                    |m: &Confirmation| { &m.field_type },
                    |m: &mut Confirmation| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "first_message_id",
                    |m: &Confirmation| { &m.first_message_id },
                    |m: &mut Confirmation| { &mut m.first_message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "more_message_ids",
                    |m: &Confirmation| { &m.more_message_ids },
                    |m: &mut Confirmation| { &mut m.more_message_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Confirmation>(
                    "Confirmation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Confirmation {
        static mut instance: ::protobuf::lazy::Lazy<Confirmation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Confirmation,
        };
        unsafe {
            instance.get(Confirmation::new)
        }
    }
}

impl ::protobuf::Clear for Confirmation {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.first_message_id.clear();
        self.more_message_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Confirmation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Confirmation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Confirmation_Type {
    DELIVERED = 0,
    READ = 1,
}

impl ::protobuf::ProtobufEnum for Confirmation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Confirmation_Type> {
        match value {
            0 => ::std::option::Option::Some(Confirmation_Type::DELIVERED),
            1 => ::std::option::Option::Some(Confirmation_Type::READ),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Confirmation_Type] = &[
            Confirmation_Type::DELIVERED,
            Confirmation_Type::READ,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Confirmation_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Confirmation_Type {
}

impl ::std::default::Default for Confirmation_Type {
    fn default() -> Self {
        Confirmation_Type::DELIVERED
    }
}

impl ::protobuf::reflect::ProtobufValue for Confirmation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location {
    // message fields
    longitude: ::std::option::Option<f32>,
    latitude: ::std::option::Option<f32>,
    name: ::protobuf::SingularField<::std::string::String>,
    zoom: ::std::option::Option<i32>,
    expects_read_confirmation: ::std::option::Option<bool>,
    legal_hold_status: ::std::option::Option<LegalHoldStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // required float longitude = 1;


    pub fn get_longitude(&self) -> f32 {
        self.longitude.unwrap_or(0.)
    }
    pub fn clear_longitude(&mut self) {
        self.longitude = ::std::option::Option::None;
    }

    pub fn has_longitude(&self) -> bool {
        self.longitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_longitude(&mut self, v: f32) {
        self.longitude = ::std::option::Option::Some(v);
    }

    // required float latitude = 2;


    pub fn get_latitude(&self) -> f32 {
        self.latitude.unwrap_or(0.)
    }
    pub fn clear_latitude(&mut self) {
        self.latitude = ::std::option::Option::None;
    }

    pub fn has_latitude(&self) -> bool {
        self.latitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latitude(&mut self, v: f32) {
        self.latitude = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 zoom = 4;


    pub fn get_zoom(&self) -> i32 {
        self.zoom.unwrap_or(0)
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = ::std::option::Option::None;
    }

    pub fn has_zoom(&self) -> bool {
        self.zoom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: i32) {
        self.zoom = ::std::option::Option::Some(v);
    }

    // optional bool expects_read_confirmation = 5;


    pub fn get_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.unwrap_or(false)
    }
    pub fn clear_expects_read_confirmation(&mut self) {
        self.expects_read_confirmation = ::std::option::Option::None;
    }

    pub fn has_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expects_read_confirmation(&mut self, v: bool) {
        self.expects_read_confirmation = ::std::option::Option::Some(v);
    }

    // optional .LegalHoldStatus legal_hold_status = 6;


    pub fn get_legal_hold_status(&self) -> LegalHoldStatus {
        self.legal_hold_status.unwrap_or(LegalHoldStatus::UNKNOWN)
    }
    pub fn clear_legal_hold_status(&mut self) {
        self.legal_hold_status = ::std::option::Option::None;
    }

    pub fn has_legal_hold_status(&self) -> bool {
        self.legal_hold_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legal_hold_status(&mut self, v: LegalHoldStatus) {
        self.legal_hold_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Location {
    fn is_initialized(&self) -> bool {
        if self.longitude.is_none() {
            return false;
        }
        if self.latitude.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.longitude = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.latitude = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.zoom = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expects_read_confirmation = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.legal_hold_status, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.longitude {
            my_size += 5;
        }
        if let Some(v) = self.latitude {
            my_size += 5;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.zoom {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expects_read_confirmation {
            my_size += 2;
        }
        if let Some(v) = self.legal_hold_status {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.longitude {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.latitude {
            os.write_float(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.zoom {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.expects_read_confirmation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.legal_hold_status {
            os.write_enum(6, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location {
        Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "longitude",
                    |m: &Location| { &m.longitude },
                    |m: &mut Location| { &mut m.longitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "latitude",
                    |m: &Location| { &m.latitude },
                    |m: &mut Location| { &mut m.latitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Location| { &m.name },
                    |m: &mut Location| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "zoom",
                    |m: &Location| { &m.zoom },
                    |m: &mut Location| { &mut m.zoom },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "expects_read_confirmation",
                    |m: &Location| { &m.expects_read_confirmation },
                    |m: &mut Location| { &mut m.expects_read_confirmation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegalHoldStatus>>(
                    "legal_hold_status",
                    |m: &Location| { &m.legal_hold_status },
                    |m: &mut Location| { &mut m.legal_hold_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Location>(
                    "Location",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Location {
        static mut instance: ::protobuf::lazy::Lazy<Location> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Location,
        };
        unsafe {
            instance.get(Location::new)
        }
    }
}

impl ::protobuf::Clear for Location {
    fn clear(&mut self) {
        self.longitude = ::std::option::Option::None;
        self.latitude = ::std::option::Option::None;
        self.name.clear();
        self.zoom = ::std::option::Option::None;
        self.expects_read_confirmation = ::std::option::Option::None;
        self.legal_hold_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImageAsset {
    // message fields
    tag: ::protobuf::SingularField<::std::string::String>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    original_width: ::std::option::Option<i32>,
    original_height: ::std::option::Option<i32>,
    mime_type: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<i32>,
    otr_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mac_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImageAsset {
    fn default() -> &'a ImageAsset {
        <ImageAsset as ::protobuf::Message>::default_instance()
    }
}

impl ImageAsset {
    pub fn new() -> ImageAsset {
        ::std::default::Default::default()
    }

    // required string tag = 1;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag.set_default();
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 width = 2;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required int32 height = 3;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // required int32 original_width = 4;


    pub fn get_original_width(&self) -> i32 {
        self.original_width.unwrap_or(0)
    }
    pub fn clear_original_width(&mut self) {
        self.original_width = ::std::option::Option::None;
    }

    pub fn has_original_width(&self) -> bool {
        self.original_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_width(&mut self, v: i32) {
        self.original_width = ::std::option::Option::Some(v);
    }

    // required int32 original_height = 5;


    pub fn get_original_height(&self) -> i32 {
        self.original_height.unwrap_or(0)
    }
    pub fn clear_original_height(&mut self) {
        self.original_height = ::std::option::Option::None;
    }

    pub fn has_original_height(&self) -> bool {
        self.original_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_height(&mut self, v: i32) {
        self.original_height = ::std::option::Option::Some(v);
    }

    // required string mime_type = 6;


    pub fn get_mime_type(&self) -> &str {
        match self.mime_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    pub fn has_mime_type(&self) -> bool {
        self.mime_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        if self.mime_type.is_none() {
            self.mime_type.set_default();
        }
        self.mime_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        self.mime_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 size = 7;


    pub fn get_size(&self) -> i32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional bytes otr_key = 8;


    pub fn get_otr_key(&self) -> &[u8] {
        match self.otr_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_otr_key(&mut self) {
        self.otr_key.clear();
    }

    pub fn has_otr_key(&self) -> bool {
        self.otr_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otr_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.otr_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otr_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otr_key.is_none() {
            self.otr_key.set_default();
        }
        self.otr_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_otr_key(&mut self) -> ::std::vec::Vec<u8> {
        self.otr_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mac_key = 9;


    pub fn get_mac_key(&self) -> &[u8] {
        match self.mac_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mac_key(&mut self) {
        self.mac_key.clear();
    }

    pub fn has_mac_key(&self) -> bool {
        self.mac_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac_key.is_none() {
            self.mac_key.set_default();
        }
        self.mac_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac_key(&mut self) -> ::std::vec::Vec<u8> {
        self.mac_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mac = 10;


    pub fn get_mac(&self) -> &[u8] {
        match self.mac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mac(&mut self) {
        self.mac.clear();
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac.is_none() {
            self.mac.set_default();
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::vec::Vec<u8> {
        self.mac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sha256 = 11;


    pub fn get_sha256(&self) -> &[u8] {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha256(&mut self) {
        self.sha256.clear();
    }

    pub fn has_sha256(&self) -> bool {
        self.sha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha256 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha256.is_none() {
            self.sha256.set_default();
        }
        self.sha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha256(&mut self) -> ::std::vec::Vec<u8> {
        self.sha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ImageAsset {
    fn is_initialized(&self) -> bool {
        if self.tag.is_none() {
            return false;
        }
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        if self.original_width.is_none() {
            return false;
        }
        if self.original_height.is_none() {
            return false;
        }
        if self.mime_type.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.original_width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.original_height = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mime_type)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otr_key)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mac_key)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mac)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.original_width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.original_height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mime_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.otr_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.mac_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(ref v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.original_width {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.original_height {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.mime_type.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.size {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.otr_key.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.mac_key.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(ref v) = self.mac.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_bytes(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImageAsset {
        ImageAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tag",
                    |m: &ImageAsset| { &m.tag },
                    |m: &mut ImageAsset| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &ImageAsset| { &m.width },
                    |m: &mut ImageAsset| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &ImageAsset| { &m.height },
                    |m: &mut ImageAsset| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "original_width",
                    |m: &ImageAsset| { &m.original_width },
                    |m: &mut ImageAsset| { &mut m.original_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "original_height",
                    |m: &ImageAsset| { &m.original_height },
                    |m: &mut ImageAsset| { &mut m.original_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mime_type",
                    |m: &ImageAsset| { &m.mime_type },
                    |m: &mut ImageAsset| { &mut m.mime_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "size",
                    |m: &ImageAsset| { &m.size },
                    |m: &mut ImageAsset| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "otr_key",
                    |m: &ImageAsset| { &m.otr_key },
                    |m: &mut ImageAsset| { &mut m.otr_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "mac_key",
                    |m: &ImageAsset| { &m.mac_key },
                    |m: &mut ImageAsset| { &mut m.mac_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "mac",
                    |m: &ImageAsset| { &m.mac },
                    |m: &mut ImageAsset| { &mut m.mac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sha256",
                    |m: &ImageAsset| { &m.sha256 },
                    |m: &mut ImageAsset| { &mut m.sha256 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImageAsset>(
                    "ImageAsset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImageAsset {
        static mut instance: ::protobuf::lazy::Lazy<ImageAsset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImageAsset,
        };
        unsafe {
            instance.get(ImageAsset::new)
        }
    }
}

impl ::protobuf::Clear for ImageAsset {
    fn clear(&mut self) {
        self.tag.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.original_width = ::std::option::Option::None;
        self.original_height = ::std::option::Option::None;
        self.mime_type.clear();
        self.size = ::std::option::Option::None;
        self.otr_key.clear();
        self.mac_key.clear();
        self.mac.clear();
        self.sha256.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImageAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset {
    // message fields
    original: ::protobuf::SingularPtrField<Asset_Original>,
    preview: ::protobuf::SingularPtrField<Asset_Preview>,
    expects_read_confirmation: ::std::option::Option<bool>,
    legal_hold_status: ::std::option::Option<LegalHoldStatus>,
    // message oneof groups
    pub status: ::std::option::Option<Asset_oneof_status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset {
    fn default() -> &'a Asset {
        <Asset as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Asset_oneof_status {
    not_uploaded(Asset_NotUploaded),
    uploaded(Asset_RemoteData),
}

impl Asset {
    pub fn new() -> Asset {
        ::std::default::Default::default()
    }

    // optional .Asset.Original original = 1;


    pub fn get_original(&self) -> &Asset_Original {
        self.original.as_ref().unwrap_or_else(|| Asset_Original::default_instance())
    }
    pub fn clear_original(&mut self) {
        self.original.clear();
    }

    pub fn has_original(&self) -> bool {
        self.original.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original(&mut self, v: Asset_Original) {
        self.original = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original(&mut self) -> &mut Asset_Original {
        if self.original.is_none() {
            self.original.set_default();
        }
        self.original.as_mut().unwrap()
    }

    // Take field
    pub fn take_original(&mut self) -> Asset_Original {
        self.original.take().unwrap_or_else(|| Asset_Original::new())
    }

    // optional .Asset.NotUploaded not_uploaded = 3;


    pub fn get_not_uploaded(&self) -> Asset_NotUploaded {
        match self.status {
            ::std::option::Option::Some(Asset_oneof_status::not_uploaded(v)) => v,
            _ => Asset_NotUploaded::CANCELLED,
        }
    }
    pub fn clear_not_uploaded(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_not_uploaded(&self) -> bool {
        match self.status {
            ::std::option::Option::Some(Asset_oneof_status::not_uploaded(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_uploaded(&mut self, v: Asset_NotUploaded) {
        self.status = ::std::option::Option::Some(Asset_oneof_status::not_uploaded(v))
    }

    // optional .Asset.RemoteData uploaded = 4;


    pub fn get_uploaded(&self) -> &Asset_RemoteData {
        match self.status {
            ::std::option::Option::Some(Asset_oneof_status::uploaded(ref v)) => v,
            _ => Asset_RemoteData::default_instance(),
        }
    }
    pub fn clear_uploaded(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_uploaded(&self) -> bool {
        match self.status {
            ::std::option::Option::Some(Asset_oneof_status::uploaded(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uploaded(&mut self, v: Asset_RemoteData) {
        self.status = ::std::option::Option::Some(Asset_oneof_status::uploaded(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uploaded(&mut self) -> &mut Asset_RemoteData {
        if let ::std::option::Option::Some(Asset_oneof_status::uploaded(_)) = self.status {
        } else {
            self.status = ::std::option::Option::Some(Asset_oneof_status::uploaded(Asset_RemoteData::new()));
        }
        match self.status {
            ::std::option::Option::Some(Asset_oneof_status::uploaded(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uploaded(&mut self) -> Asset_RemoteData {
        if self.has_uploaded() {
            match self.status.take() {
                ::std::option::Option::Some(Asset_oneof_status::uploaded(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset_RemoteData::new()
        }
    }

    // optional .Asset.Preview preview = 5;


    pub fn get_preview(&self) -> &Asset_Preview {
        self.preview.as_ref().unwrap_or_else(|| Asset_Preview::default_instance())
    }
    pub fn clear_preview(&mut self) {
        self.preview.clear();
    }

    pub fn has_preview(&self) -> bool {
        self.preview.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview(&mut self, v: Asset_Preview) {
        self.preview = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview(&mut self) -> &mut Asset_Preview {
        if self.preview.is_none() {
            self.preview.set_default();
        }
        self.preview.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview(&mut self) -> Asset_Preview {
        self.preview.take().unwrap_or_else(|| Asset_Preview::new())
    }

    // optional bool expects_read_confirmation = 6;


    pub fn get_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.unwrap_or(false)
    }
    pub fn clear_expects_read_confirmation(&mut self) {
        self.expects_read_confirmation = ::std::option::Option::None;
    }

    pub fn has_expects_read_confirmation(&self) -> bool {
        self.expects_read_confirmation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expects_read_confirmation(&mut self, v: bool) {
        self.expects_read_confirmation = ::std::option::Option::Some(v);
    }

    // optional .LegalHoldStatus legal_hold_status = 7;


    pub fn get_legal_hold_status(&self) -> LegalHoldStatus {
        self.legal_hold_status.unwrap_or(LegalHoldStatus::UNKNOWN)
    }
    pub fn clear_legal_hold_status(&mut self) {
        self.legal_hold_status = ::std::option::Option::None;
    }

    pub fn has_legal_hold_status(&self) -> bool {
        self.legal_hold_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legal_hold_status(&mut self, v: LegalHoldStatus) {
        self.legal_hold_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Asset {
    fn is_initialized(&self) -> bool {
        for v in &self.original {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Asset_oneof_status::uploaded(ref v)) = self.status {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.preview {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = ::std::option::Option::Some(Asset_oneof_status::not_uploaded(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.status = ::std::option::Option::Some(Asset_oneof_status::uploaded(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preview)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expects_read_confirmation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.legal_hold_status, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preview.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.expects_read_confirmation {
            my_size += 2;
        }
        if let Some(v) = self.legal_hold_status {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let ::std::option::Option::Some(ref v) = self.status {
            match v {
                &Asset_oneof_status::not_uploaded(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &Asset_oneof_status::uploaded(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preview.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.expects_read_confirmation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.legal_hold_status {
            os.write_enum(7, v.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.status {
            match v {
                &Asset_oneof_status::not_uploaded(v) => {
                    os.write_enum(3, v.value())?;
                },
                &Asset_oneof_status::uploaded(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset {
        Asset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asset_Original>>(
                    "original",
                    |m: &Asset| { &m.original },
                    |m: &mut Asset| { &mut m.original },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, Asset_NotUploaded>(
                    "not_uploaded",
                    Asset::has_not_uploaded,
                    Asset::get_not_uploaded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset_RemoteData>(
                    "uploaded",
                    Asset::has_uploaded,
                    Asset::get_uploaded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asset_Preview>>(
                    "preview",
                    |m: &Asset| { &m.preview },
                    |m: &mut Asset| { &mut m.preview },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "expects_read_confirmation",
                    |m: &Asset| { &m.expects_read_confirmation },
                    |m: &mut Asset| { &mut m.expects_read_confirmation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegalHoldStatus>>(
                    "legal_hold_status",
                    |m: &Asset| { &m.legal_hold_status },
                    |m: &mut Asset| { &mut m.legal_hold_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset>(
                    "Asset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset {
        static mut instance: ::protobuf::lazy::Lazy<Asset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset,
        };
        unsafe {
            instance.get(Asset::new)
        }
    }
}

impl ::protobuf::Clear for Asset {
    fn clear(&mut self) {
        self.original.clear();
        self.status = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.preview.clear();
        self.expects_read_confirmation = ::std::option::Option::None;
        self.legal_hold_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_Original {
    // message fields
    mime_type: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    caption: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub meta_data: ::std::option::Option<Asset_Original_oneof_meta_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_Original {
    fn default() -> &'a Asset_Original {
        <Asset_Original as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Asset_Original_oneof_meta_data {
    image(Asset_ImageMetaData),
    video(Asset_VideoMetaData),
    audio(Asset_AudioMetaData),
}

impl Asset_Original {
    pub fn new() -> Asset_Original {
        ::std::default::Default::default()
    }

    // required string mime_type = 1;


    pub fn get_mime_type(&self) -> &str {
        match self.mime_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    pub fn has_mime_type(&self) -> bool {
        self.mime_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        if self.mime_type.is_none() {
            self.mime_type.set_default();
        }
        self.mime_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        self.mime_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 size = 2;


    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Asset.ImageMetaData image = 4;


    pub fn get_image(&self) -> &Asset_ImageMetaData {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(ref v)) => v,
            _ => Asset_ImageMetaData::default_instance(),
        }
    }
    pub fn clear_image(&mut self) {
        self.meta_data = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Asset_ImageMetaData) {
        self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut Asset_ImageMetaData {
        if let ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(_)) = self.meta_data {
        } else {
            self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(Asset_ImageMetaData::new()));
        }
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> Asset_ImageMetaData {
        if self.has_image() {
            match self.meta_data.take() {
                ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset_ImageMetaData::new()
        }
    }

    // optional .Asset.VideoMetaData video = 5;


    pub fn get_video(&self) -> &Asset_VideoMetaData {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(ref v)) => v,
            _ => Asset_VideoMetaData::default_instance(),
        }
    }
    pub fn clear_video(&mut self) {
        self.meta_data = ::std::option::Option::None;
    }

    pub fn has_video(&self) -> bool {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_video(&mut self, v: Asset_VideoMetaData) {
        self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(v))
    }

    // Mutable pointer to the field.
    pub fn mut_video(&mut self) -> &mut Asset_VideoMetaData {
        if let ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(_)) = self.meta_data {
        } else {
            self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(Asset_VideoMetaData::new()));
        }
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_video(&mut self) -> Asset_VideoMetaData {
        if self.has_video() {
            match self.meta_data.take() {
                ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset_VideoMetaData::new()
        }
    }

    // optional .Asset.AudioMetaData audio = 6;


    pub fn get_audio(&self) -> &Asset_AudioMetaData {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(ref v)) => v,
            _ => Asset_AudioMetaData::default_instance(),
        }
    }
    pub fn clear_audio(&mut self) {
        self.meta_data = ::std::option::Option::None;
    }

    pub fn has_audio(&self) -> bool {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: Asset_AudioMetaData) {
        self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio(&mut self) -> &mut Asset_AudioMetaData {
        if let ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(_)) = self.meta_data {
        } else {
            self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(Asset_AudioMetaData::new()));
        }
        match self.meta_data {
            ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio(&mut self) -> Asset_AudioMetaData {
        if self.has_audio() {
            match self.meta_data.take() {
                ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset_AudioMetaData::new()
        }
    }

    // optional string source = 7;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 8;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Asset_Original {
    fn is_initialized(&self) -> bool {
        if self.mime_type.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if let Some(Asset_Original_oneof_meta_data::image(ref v)) = self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Asset_Original_oneof_meta_data::video(ref v)) = self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Asset_Original_oneof_meta_data::audio(ref v)) = self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mime_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::image(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::video(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data = ::std::option::Option::Some(Asset_Original_oneof_meta_data::audio(is.read_message()?));
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mime_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &Asset_Original_oneof_meta_data::image(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Asset_Original_oneof_meta_data::video(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Asset_Original_oneof_meta_data::audio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mime_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(8, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &Asset_Original_oneof_meta_data::image(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Asset_Original_oneof_meta_data::video(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Asset_Original_oneof_meta_data::audio(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_Original {
        Asset_Original::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mime_type",
                    |m: &Asset_Original| { &m.mime_type },
                    |m: &mut Asset_Original| { &mut m.mime_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    |m: &Asset_Original| { &m.size },
                    |m: &mut Asset_Original| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Asset_Original| { &m.name },
                    |m: &mut Asset_Original| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset_ImageMetaData>(
                    "image",
                    Asset_Original::has_image,
                    Asset_Original::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset_VideoMetaData>(
                    "video",
                    Asset_Original::has_video,
                    Asset_Original::get_video,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset_AudioMetaData>(
                    "audio",
                    Asset_Original::has_audio,
                    Asset_Original::get_audio,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &Asset_Original| { &m.source },
                    |m: &mut Asset_Original| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "caption",
                    |m: &Asset_Original| { &m.caption },
                    |m: &mut Asset_Original| { &mut m.caption },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_Original>(
                    "Asset_Original",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_Original {
        static mut instance: ::protobuf::lazy::Lazy<Asset_Original> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_Original,
        };
        unsafe {
            instance.get(Asset_Original::new)
        }
    }
}

impl ::protobuf::Clear for Asset_Original {
    fn clear(&mut self) {
        self.mime_type.clear();
        self.size = ::std::option::Option::None;
        self.name.clear();
        self.meta_data = ::std::option::Option::None;
        self.meta_data = ::std::option::Option::None;
        self.meta_data = ::std::option::Option::None;
        self.source.clear();
        self.caption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_Original {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_Original {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_Preview {
    // message fields
    mime_type: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<u64>,
    remote: ::protobuf::SingularPtrField<Asset_RemoteData>,
    // message oneof groups
    pub meta_data: ::std::option::Option<Asset_Preview_oneof_meta_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_Preview {
    fn default() -> &'a Asset_Preview {
        <Asset_Preview as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Asset_Preview_oneof_meta_data {
    image(Asset_ImageMetaData),
}

impl Asset_Preview {
    pub fn new() -> Asset_Preview {
        ::std::default::Default::default()
    }

    // required string mime_type = 1;


    pub fn get_mime_type(&self) -> &str {
        match self.mime_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mime_type(&mut self) {
        self.mime_type.clear();
    }

    pub fn has_mime_type(&self) -> bool {
        self.mime_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mime_type(&mut self, v: ::std::string::String) {
        self.mime_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mime_type(&mut self) -> &mut ::std::string::String {
        if self.mime_type.is_none() {
            self.mime_type.set_default();
        }
        self.mime_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_mime_type(&mut self) -> ::std::string::String {
        self.mime_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 size = 2;


    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional .Asset.RemoteData remote = 3;


    pub fn get_remote(&self) -> &Asset_RemoteData {
        self.remote.as_ref().unwrap_or_else(|| Asset_RemoteData::default_instance())
    }
    pub fn clear_remote(&mut self) {
        self.remote.clear();
    }

    pub fn has_remote(&self) -> bool {
        self.remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote(&mut self, v: Asset_RemoteData) {
        self.remote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote(&mut self) -> &mut Asset_RemoteData {
        if self.remote.is_none() {
            self.remote.set_default();
        }
        self.remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote(&mut self) -> Asset_RemoteData {
        self.remote.take().unwrap_or_else(|| Asset_RemoteData::new())
    }

    // optional .Asset.ImageMetaData image = 4;


    pub fn get_image(&self) -> &Asset_ImageMetaData {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(ref v)) => v,
            _ => Asset_ImageMetaData::default_instance(),
        }
    }
    pub fn clear_image(&mut self) {
        self.meta_data = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.meta_data {
            ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Asset_ImageMetaData) {
        self.meta_data = ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut Asset_ImageMetaData {
        if let ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(_)) = self.meta_data {
        } else {
            self.meta_data = ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(Asset_ImageMetaData::new()));
        }
        match self.meta_data {
            ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> Asset_ImageMetaData {
        if self.has_image() {
            match self.meta_data.take() {
                ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(v)) => v,
                _ => panic!(),
            }
        } else {
            Asset_ImageMetaData::new()
        }
    }
}

impl ::protobuf::Message for Asset_Preview {
    fn is_initialized(&self) -> bool {
        if self.mime_type.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        for v in &self.remote {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Asset_Preview_oneof_meta_data::image(ref v)) = self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mime_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.meta_data = ::std::option::Option::Some(Asset_Preview_oneof_meta_data::image(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mime_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.remote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &Asset_Preview_oneof_meta_data::image(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mime_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.remote.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.meta_data {
            match v {
                &Asset_Preview_oneof_meta_data::image(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_Preview {
        Asset_Preview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mime_type",
                    |m: &Asset_Preview| { &m.mime_type },
                    |m: &mut Asset_Preview| { &mut m.mime_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    |m: &Asset_Preview| { &m.size },
                    |m: &mut Asset_Preview| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Asset_RemoteData>>(
                    "remote",
                    |m: &Asset_Preview| { &m.remote },
                    |m: &mut Asset_Preview| { &mut m.remote },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Asset_ImageMetaData>(
                    "image",
                    Asset_Preview::has_image,
                    Asset_Preview::get_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_Preview>(
                    "Asset_Preview",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_Preview {
        static mut instance: ::protobuf::lazy::Lazy<Asset_Preview> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_Preview,
        };
        unsafe {
            instance.get(Asset_Preview::new)
        }
    }
}

impl ::protobuf::Clear for Asset_Preview {
    fn clear(&mut self) {
        self.mime_type.clear();
        self.size = ::std::option::Option::None;
        self.remote.clear();
        self.meta_data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_Preview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_Preview {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_ImageMetaData {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    tag: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_ImageMetaData {
    fn default() -> &'a Asset_ImageMetaData {
        <Asset_ImageMetaData as ::protobuf::Message>::default_instance()
    }
}

impl Asset_ImageMetaData {
    pub fn new() -> Asset_ImageMetaData {
        ::std::default::Default::default()
    }

    // required int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional string tag = 3;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag.set_default();
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Asset_ImageMetaData {
    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_ImageMetaData {
        Asset_ImageMetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &Asset_ImageMetaData| { &m.width },
                    |m: &mut Asset_ImageMetaData| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &Asset_ImageMetaData| { &m.height },
                    |m: &mut Asset_ImageMetaData| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tag",
                    |m: &Asset_ImageMetaData| { &m.tag },
                    |m: &mut Asset_ImageMetaData| { &mut m.tag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_ImageMetaData>(
                    "Asset_ImageMetaData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_ImageMetaData {
        static mut instance: ::protobuf::lazy::Lazy<Asset_ImageMetaData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_ImageMetaData,
        };
        unsafe {
            instance.get(Asset_ImageMetaData::new)
        }
    }
}

impl ::protobuf::Clear for Asset_ImageMetaData {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_ImageMetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_ImageMetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_VideoMetaData {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    duration_in_millis: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_VideoMetaData {
    fn default() -> &'a Asset_VideoMetaData {
        <Asset_VideoMetaData as ::protobuf::Message>::default_instance()
    }
}

impl Asset_VideoMetaData {
    pub fn new() -> Asset_VideoMetaData {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint64 duration_in_millis = 3;


    pub fn get_duration_in_millis(&self) -> u64 {
        self.duration_in_millis.unwrap_or(0)
    }
    pub fn clear_duration_in_millis(&mut self) {
        self.duration_in_millis = ::std::option::Option::None;
    }

    pub fn has_duration_in_millis(&self) -> bool {
        self.duration_in_millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_in_millis(&mut self, v: u64) {
        self.duration_in_millis = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Asset_VideoMetaData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.duration_in_millis = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration_in_millis {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration_in_millis {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_VideoMetaData {
        Asset_VideoMetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "width",
                    |m: &Asset_VideoMetaData| { &m.width },
                    |m: &mut Asset_VideoMetaData| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "height",
                    |m: &Asset_VideoMetaData| { &m.height },
                    |m: &mut Asset_VideoMetaData| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "duration_in_millis",
                    |m: &Asset_VideoMetaData| { &m.duration_in_millis },
                    |m: &mut Asset_VideoMetaData| { &mut m.duration_in_millis },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_VideoMetaData>(
                    "Asset_VideoMetaData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_VideoMetaData {
        static mut instance: ::protobuf::lazy::Lazy<Asset_VideoMetaData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_VideoMetaData,
        };
        unsafe {
            instance.get(Asset_VideoMetaData::new)
        }
    }
}

impl ::protobuf::Clear for Asset_VideoMetaData {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.duration_in_millis = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_VideoMetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_VideoMetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_AudioMetaData {
    // message fields
    duration_in_millis: ::std::option::Option<u64>,
    normalized_loudness: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_AudioMetaData {
    fn default() -> &'a Asset_AudioMetaData {
        <Asset_AudioMetaData as ::protobuf::Message>::default_instance()
    }
}

impl Asset_AudioMetaData {
    pub fn new() -> Asset_AudioMetaData {
        ::std::default::Default::default()
    }

    // optional uint64 duration_in_millis = 1;


    pub fn get_duration_in_millis(&self) -> u64 {
        self.duration_in_millis.unwrap_or(0)
    }
    pub fn clear_duration_in_millis(&mut self) {
        self.duration_in_millis = ::std::option::Option::None;
    }

    pub fn has_duration_in_millis(&self) -> bool {
        self.duration_in_millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_in_millis(&mut self, v: u64) {
        self.duration_in_millis = ::std::option::Option::Some(v);
    }

    // optional bytes normalized_loudness = 3;


    pub fn get_normalized_loudness(&self) -> &[u8] {
        match self.normalized_loudness.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_normalized_loudness(&mut self) {
        self.normalized_loudness.clear();
    }

    pub fn has_normalized_loudness(&self) -> bool {
        self.normalized_loudness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_loudness(&mut self, v: ::std::vec::Vec<u8>) {
        self.normalized_loudness = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_normalized_loudness(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.normalized_loudness.is_none() {
            self.normalized_loudness.set_default();
        }
        self.normalized_loudness.as_mut().unwrap()
    }

    // Take field
    pub fn take_normalized_loudness(&mut self) -> ::std::vec::Vec<u8> {
        self.normalized_loudness.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Asset_AudioMetaData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.duration_in_millis = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.normalized_loudness)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration_in_millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.normalized_loudness.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration_in_millis {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.normalized_loudness.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_AudioMetaData {
        Asset_AudioMetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "duration_in_millis",
                    |m: &Asset_AudioMetaData| { &m.duration_in_millis },
                    |m: &mut Asset_AudioMetaData| { &mut m.duration_in_millis },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "normalized_loudness",
                    |m: &Asset_AudioMetaData| { &m.normalized_loudness },
                    |m: &mut Asset_AudioMetaData| { &mut m.normalized_loudness },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_AudioMetaData>(
                    "Asset_AudioMetaData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_AudioMetaData {
        static mut instance: ::protobuf::lazy::Lazy<Asset_AudioMetaData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_AudioMetaData,
        };
        unsafe {
            instance.get(Asset_AudioMetaData::new)
        }
    }
}

impl ::protobuf::Clear for Asset_AudioMetaData {
    fn clear(&mut self) {
        self.duration_in_millis = ::std::option::Option::None;
        self.normalized_loudness.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_AudioMetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_AudioMetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Asset_RemoteData {
    // message fields
    otr_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    asset_id: ::protobuf::SingularField<::std::string::String>,
    asset_token: ::protobuf::SingularField<::std::string::String>,
    encryption: ::std::option::Option<EncryptionAlgorithm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Asset_RemoteData {
    fn default() -> &'a Asset_RemoteData {
        <Asset_RemoteData as ::protobuf::Message>::default_instance()
    }
}

impl Asset_RemoteData {
    pub fn new() -> Asset_RemoteData {
        ::std::default::Default::default()
    }

    // required bytes otr_key = 1;


    pub fn get_otr_key(&self) -> &[u8] {
        match self.otr_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_otr_key(&mut self) {
        self.otr_key.clear();
    }

    pub fn has_otr_key(&self) -> bool {
        self.otr_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otr_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.otr_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otr_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otr_key.is_none() {
            self.otr_key.set_default();
        }
        self.otr_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_otr_key(&mut self) -> ::std::vec::Vec<u8> {
        self.otr_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes sha256 = 2;


    pub fn get_sha256(&self) -> &[u8] {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha256(&mut self) {
        self.sha256.clear();
    }

    pub fn has_sha256(&self) -> bool {
        self.sha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha256 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha256.is_none() {
            self.sha256.set_default();
        }
        self.sha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha256(&mut self) -> ::std::vec::Vec<u8> {
        self.sha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string asset_id = 3;


    pub fn get_asset_id(&self) -> &str {
        match self.asset_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_asset_id(&mut self) {
        self.asset_id.clear();
    }

    pub fn has_asset_id(&self) -> bool {
        self.asset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_id(&mut self, v: ::std::string::String) {
        self.asset_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_id(&mut self) -> &mut ::std::string::String {
        if self.asset_id.is_none() {
            self.asset_id.set_default();
        }
        self.asset_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_asset_id(&mut self) -> ::std::string::String {
        self.asset_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string asset_token = 5;


    pub fn get_asset_token(&self) -> &str {
        match self.asset_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_asset_token(&mut self) {
        self.asset_token.clear();
    }

    pub fn has_asset_token(&self) -> bool {
        self.asset_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_token(&mut self, v: ::std::string::String) {
        self.asset_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_token(&mut self) -> &mut ::std::string::String {
        if self.asset_token.is_none() {
            self.asset_token.set_default();
        }
        self.asset_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_asset_token(&mut self) -> ::std::string::String {
        self.asset_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EncryptionAlgorithm encryption = 6;


    pub fn get_encryption(&self) -> EncryptionAlgorithm {
        self.encryption.unwrap_or(EncryptionAlgorithm::AES_CBC)
    }
    pub fn clear_encryption(&mut self) {
        self.encryption = ::std::option::Option::None;
    }

    pub fn has_encryption(&self) -> bool {
        self.encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption(&mut self, v: EncryptionAlgorithm) {
        self.encryption = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Asset_RemoteData {
    fn is_initialized(&self) -> bool {
        if self.otr_key.is_none() {
            return false;
        }
        if self.sha256.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otr_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.asset_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.asset_token)?;
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.otr_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.asset_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.asset_token.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.encryption {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.otr_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.asset_id.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.asset_token.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.encryption {
            os.write_enum(6, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Asset_RemoteData {
        Asset_RemoteData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "otr_key",
                    |m: &Asset_RemoteData| { &m.otr_key },
                    |m: &mut Asset_RemoteData| { &mut m.otr_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sha256",
                    |m: &Asset_RemoteData| { &m.sha256 },
                    |m: &mut Asset_RemoteData| { &mut m.sha256 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "asset_id",
                    |m: &Asset_RemoteData| { &m.asset_id },
                    |m: &mut Asset_RemoteData| { &mut m.asset_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "asset_token",
                    |m: &Asset_RemoteData| { &m.asset_token },
                    |m: &mut Asset_RemoteData| { &mut m.asset_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptionAlgorithm>>(
                    "encryption",
                    |m: &Asset_RemoteData| { &m.encryption },
                    |m: &mut Asset_RemoteData| { &mut m.encryption },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Asset_RemoteData>(
                    "Asset_RemoteData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Asset_RemoteData {
        static mut instance: ::protobuf::lazy::Lazy<Asset_RemoteData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Asset_RemoteData,
        };
        unsafe {
            instance.get(Asset_RemoteData::new)
        }
    }
}

impl ::protobuf::Clear for Asset_RemoteData {
    fn clear(&mut self) {
        self.otr_key.clear();
        self.sha256.clear();
        self.asset_id.clear();
        self.asset_token.clear();
        self.encryption = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Asset_RemoteData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_RemoteData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Asset_NotUploaded {
    CANCELLED = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for Asset_NotUploaded {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Asset_NotUploaded> {
        match value {
            0 => ::std::option::Option::Some(Asset_NotUploaded::CANCELLED),
            1 => ::std::option::Option::Some(Asset_NotUploaded::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Asset_NotUploaded] = &[
            Asset_NotUploaded::CANCELLED,
            Asset_NotUploaded::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Asset_NotUploaded", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Asset_NotUploaded {
}

impl ::std::default::Default for Asset_NotUploaded {
    fn default() -> Self {
        Asset_NotUploaded::CANCELLED
    }
}

impl ::protobuf::reflect::ProtobufValue for Asset_NotUploaded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct External {
    // message fields
    otr_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sha256: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    encryption: ::std::option::Option<EncryptionAlgorithm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a External {
    fn default() -> &'a External {
        <External as ::protobuf::Message>::default_instance()
    }
}

impl External {
    pub fn new() -> External {
        ::std::default::Default::default()
    }

    // required bytes otr_key = 1;


    pub fn get_otr_key(&self) -> &[u8] {
        match self.otr_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_otr_key(&mut self) {
        self.otr_key.clear();
    }

    pub fn has_otr_key(&self) -> bool {
        self.otr_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otr_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.otr_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otr_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otr_key.is_none() {
            self.otr_key.set_default();
        }
        self.otr_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_otr_key(&mut self) -> ::std::vec::Vec<u8> {
        self.otr_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sha256 = 2;


    pub fn get_sha256(&self) -> &[u8] {
        match self.sha256.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha256(&mut self) {
        self.sha256.clear();
    }

    pub fn has_sha256(&self) -> bool {
        self.sha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha256 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha256.is_none() {
            self.sha256.set_default();
        }
        self.sha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha256(&mut self) -> ::std::vec::Vec<u8> {
        self.sha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EncryptionAlgorithm encryption = 3;


    pub fn get_encryption(&self) -> EncryptionAlgorithm {
        self.encryption.unwrap_or(EncryptionAlgorithm::AES_CBC)
    }
    pub fn clear_encryption(&mut self) {
        self.encryption = ::std::option::Option::None;
    }

    pub fn has_encryption(&self) -> bool {
        self.encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption(&mut self, v: EncryptionAlgorithm) {
        self.encryption = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for External {
    fn is_initialized(&self) -> bool {
        if self.otr_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otr_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.otr_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.sha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.encryption {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.otr_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.sha256.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.encryption {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> External {
        External::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "otr_key",
                    |m: &External| { &m.otr_key },
                    |m: &mut External| { &mut m.otr_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sha256",
                    |m: &External| { &m.sha256 },
                    |m: &mut External| { &mut m.sha256 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptionAlgorithm>>(
                    "encryption",
                    |m: &External| { &m.encryption },
                    |m: &mut External| { &mut m.encryption },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<External>(
                    "External",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static External {
        static mut instance: ::protobuf::lazy::Lazy<External> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const External,
        };
        unsafe {
            instance.get(External::new)
        }
    }
}

impl ::protobuf::Clear for External {
    fn clear(&mut self) {
        self.otr_key.clear();
        self.sha256.clear();
        self.encryption = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for External {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for External {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reaction {
    // message fields
    emoji: ::protobuf::SingularField<::std::string::String>,
    message_id: ::protobuf::SingularField<::std::string::String>,
    legal_hold_status: ::std::option::Option<LegalHoldStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reaction {
    fn default() -> &'a Reaction {
        <Reaction as ::protobuf::Message>::default_instance()
    }
}

impl Reaction {
    pub fn new() -> Reaction {
        ::std::default::Default::default()
    }

    // optional string emoji = 1;


    pub fn get_emoji(&self) -> &str {
        match self.emoji.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_emoji(&mut self) {
        self.emoji.clear();
    }

    pub fn has_emoji(&self) -> bool {
        self.emoji.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoji(&mut self, v: ::std::string::String) {
        self.emoji = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoji(&mut self) -> &mut ::std::string::String {
        if self.emoji.is_none() {
            self.emoji.set_default();
        }
        self.emoji.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoji(&mut self) -> ::std::string::String {
        self.emoji.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string message_id = 2;


    pub fn get_message_id(&self) -> &str {
        match self.message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::std::string::String) {
        self.message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut ::std::string::String {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::std::string::String {
        self.message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .LegalHoldStatus legal_hold_status = 3;


    pub fn get_legal_hold_status(&self) -> LegalHoldStatus {
        self.legal_hold_status.unwrap_or(LegalHoldStatus::UNKNOWN)
    }
    pub fn clear_legal_hold_status(&mut self) {
        self.legal_hold_status = ::std::option::Option::None;
    }

    pub fn has_legal_hold_status(&self) -> bool {
        self.legal_hold_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legal_hold_status(&mut self, v: LegalHoldStatus) {
        self.legal_hold_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Reaction {
    fn is_initialized(&self) -> bool {
        if self.message_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.emoji)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.legal_hold_status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.emoji.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.legal_hold_status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.emoji.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.legal_hold_status {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reaction {
        Reaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "emoji",
                    |m: &Reaction| { &m.emoji },
                    |m: &mut Reaction| { &mut m.emoji },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_id",
                    |m: &Reaction| { &m.message_id },
                    |m: &mut Reaction| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegalHoldStatus>>(
                    "legal_hold_status",
                    |m: &Reaction| { &m.legal_hold_status },
                    |m: &mut Reaction| { &mut m.legal_hold_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Reaction>(
                    "Reaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Reaction {
        static mut instance: ::protobuf::lazy::Lazy<Reaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Reaction,
        };
        unsafe {
            instance.get(Reaction::new)
        }
    }
}

impl ::protobuf::Clear for Reaction {
    fn clear(&mut self) {
        self.emoji.clear();
        self.message_id.clear();
        self.legal_hold_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Calling {
    // message fields
    content: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Calling {
    fn default() -> &'a Calling {
        <Calling as ::protobuf::Message>::default_instance()
    }
}

impl Calling {
    pub fn new() -> Calling {
        ::std::default::Default::default()
    }

    // required string content = 1;


    pub fn get_content(&self) -> &str {
        match self.content.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        self.content.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Calling {
    fn is_initialized(&self) -> bool {
        if self.content.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.content.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Calling {
        Calling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &Calling| { &m.content },
                    |m: &mut Calling| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Calling>(
                    "Calling",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Calling {
        static mut instance: ::protobuf::lazy::Lazy<Calling> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Calling,
        };
        unsafe {
            instance.get(Calling::new)
        }
    }
}

impl ::protobuf::Clear for Calling {
    fn clear(&mut self) {
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Calling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Calling {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientAction {
    RESET_SESSION = 0,
}

impl ::protobuf::ProtobufEnum for ClientAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientAction> {
        match value {
            0 => ::std::option::Option::Some(ClientAction::RESET_SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientAction] = &[
            ClientAction::RESET_SESSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClientAction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClientAction {
}

impl ::std::default::Default for ClientAction {
    fn default() -> Self {
        ClientAction::RESET_SESSION
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncryptionAlgorithm {
    AES_CBC = 0,
    AES_GCM = 1,
}

impl ::protobuf::ProtobufEnum for EncryptionAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptionAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(EncryptionAlgorithm::AES_CBC),
            1 => ::std::option::Option::Some(EncryptionAlgorithm::AES_GCM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncryptionAlgorithm] = &[
            EncryptionAlgorithm::AES_CBC,
            EncryptionAlgorithm::AES_GCM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncryptionAlgorithm", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncryptionAlgorithm {
}

impl ::std::default::Default for EncryptionAlgorithm {
    fn default() -> Self {
        EncryptionAlgorithm::AES_CBC
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionAlgorithm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LegalHoldStatus {
    UNKNOWN = 0,
    DISABLED = 1,
    ENABLED = 2,
}

impl ::protobuf::ProtobufEnum for LegalHoldStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegalHoldStatus> {
        match value {
            0 => ::std::option::Option::Some(LegalHoldStatus::UNKNOWN),
            1 => ::std::option::Option::Some(LegalHoldStatus::DISABLED),
            2 => ::std::option::Option::Some(LegalHoldStatus::ENABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LegalHoldStatus] = &[
            LegalHoldStatus::UNKNOWN,
            LegalHoldStatus::DISABLED,
            LegalHoldStatus::ENABLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LegalHoldStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LegalHoldStatus {
}

impl ::std::default::Default for LegalHoldStatus {
    fn default() -> Self {
        LegalHoldStatus::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for LegalHoldStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14wire_websocket.proto\"\xf3\x05\n\x0eGenericMessage\x12\x1d\n\nmess\
    age_id\x18\x01\x20\x02(\tR\tmessageId\x12\x1b\n\x04text\x18\x02\x20\x01(\
    \x0b2\x05.TextH\0R\x04text\x12#\n\x05image\x18\x03\x20\x01(\x0b2\x0b.Ima\
    geAssetH\0R\x05image\x12\x1e\n\x05knock\x18\x04\x20\x01(\x0b2\x06.KnockH\
    \0R\x05knock\x12'\n\x08lastRead\x18\x06\x20\x01(\x0b2\t.LastReadH\0R\x08\
    lastRead\x12$\n\x07cleared\x18\x07\x20\x01(\x0b2\x08.ClearedH\0R\x07clea\
    red\x12'\n\x08external\x18\x08\x20\x01(\x0b2\t.ExternalH\0R\x08external\
    \x123\n\x0cclientAction\x18\t\x20\x01(\x0e2\r.ClientActionH\0R\x0cclient\
    Action\x12$\n\x07calling\x18\n\x20\x01(\x0b2\x08.CallingH\0R\x07calling\
    \x12\x1e\n\x05asset\x18\x0b\x20\x01(\x0b2\x06.AssetH\0R\x05asset\x12&\n\
    \x06hidden\x18\x0c\x20\x01(\x0b2\x0c.MessageHideH\0R\x06hidden\x12'\n\
    \x08location\x18\r\x20\x01(\x0b2\t.LocationH\0R\x08location\x12*\n\x07de\
    leted\x18\x0e\x20\x01(\x0b2\x0e.MessageDeleteH\0R\x07deleted\x12&\n\x06e\
    dited\x18\x0f\x20\x01(\x0b2\x0c.MessageEditH\0R\x06edited\x123\n\x0cconf\
    irmation\x18\x10\x20\x01(\x0b2\r.ConfirmationH\0R\x0cconfirmation\x12'\n\
    \x08reaction\x18\x11\x20\x01(\x0b2\t.ReactionH\0R\x08reaction\x12*\n\tep\
    hemeral\x18\x12\x20\x01(\x0b2\n.EphemeralH\0R\tephemeral\x123\n\x0cavail\
    ability\x18\x13\x20\x01(\x0b2\r.AvailabilityH\0R\x0cavailabilityB\t\n\
    \x07content\"k\n\x0cAvailability\x12&\n\x04type\x18\x01\x20\x02(\x0e2\
    \x12.Availability.TypeR\x04type\"3\n\x04Type\x12\x08\n\x04NONE\x10\0\x12\
    \r\n\tAVAILABLE\x10\x01\x12\x08\n\x04AWAY\x10\x02\x12\x08\n\x04BUSY\x10\
    \x03\"\xf1\x01\n\tEphemeral\x12.\n\x13expire_after_millis\x18\x01\x20\
    \x02(\x03R\x11expireAfterMillis\x12\x1b\n\x04text\x18\x02\x20\x01(\x0b2\
    \x05.TextH\0R\x04text\x12#\n\x05image\x18\x03\x20\x01(\x0b2\x0b.ImageAss\
    etH\0R\x05image\x12\x1e\n\x05knock\x18\x04\x20\x01(\x0b2\x06.KnockH\0R\
    \x05knock\x12\x1e\n\x05asset\x18\x05\x20\x01(\x0b2\x06.AssetH\0R\x05asse\
    t\x12'\n\x08location\x18\x06\x20\x01(\x0b2\t.LocationH\0R\x08locationB\t\
    \n\x07content\"\x9f\x02\n\x04Text\x12\x18\n\x07content\x18\x01\x20\x02(\
    \tR\x07content\x12/\n\x0clink_preview\x18\x03\x20\x03(\x0b2\x0c.LinkPrev\
    iewR\x0blinkPreview\x12$\n\x08mentions\x18\x04\x20\x03(\x0b2\x08.Mention\
    R\x08mentions\x12\x1c\n\x05quote\x18\x05\x20\x01(\x0b2\x06.QuoteR\x05quo\
    te\x12A\n\x19expects_read_confirmation\x18\x06\x20\x01(\x08:\x05falseR\
    \x17expectsReadConfirmation\x12E\n\x11legal_hold_status\x18\x07\x20\x01(\
    \x0e2\x10.LegalHoldStatus:\x07UNKNOWNR\x0flegalHoldStatus\"\xb5\x01\n\
    \x05Knock\x12\"\n\thot_knock\x18\x01\x20\x02(\x08:\x05falseR\x08hotKnock\
    \x12A\n\x19expects_read_confirmation\x18\x02\x20\x01(\x08:\x05falseR\x17\
    expectsReadConfirmation\x12E\n\x11legal_hold_status\x18\x03\x20\x01(\x0e\
    2\x10.LegalHoldStatus:\x07UNKNOWNR\x0flegalHoldStatus\"\x8f\x02\n\x0bLin\
    kPreview\x12\x10\n\x03url\x18\x01\x20\x02(\tR\x03url\x12\x1d\n\nurl_offs\
    et\x18\x02\x20\x02(\x05R\turlOffset\x12$\n\x07article\x18\x03\x20\x01(\
    \x0b2\x08.ArticleH\0R\x07article\x12#\n\rpermanent_url\x18\x05\x20\x01(\
    \tR\x0cpermanentUrl\x12\x14\n\x05title\x18\x06\x20\x01(\tR\x05title\x12\
    \x18\n\x07summary\x18\x07\x20\x01(\tR\x07summary\x12\x1c\n\x05image\x18\
    \x08\x20\x01(\x0b2\x06.AssetR\x05image\x12\x1e\n\x05tweet\x18\t\x20\x01(\
    \x0b2\x06.TweetH\x01R\x05tweetB\t\n\x07previewB\x0b\n\tmeta_data\";\n\
    \x05Tweet\x12\x16\n\x06author\x18\x01\x20\x01(\tR\x06author\x12\x1a\n\
    \x08username\x18\x02\x20\x01(\tR\x08username\"|\n\x07Article\x12#\n\rper\
    manent_url\x18\x01\x20\x02(\tR\x0cpermanentUrl\x12\x14\n\x05title\x18\
    \x02\x20\x01(\tR\x05title\x12\x18\n\x07summary\x18\x03\x20\x01(\tR\x07su\
    mmary\x12\x1c\n\x05image\x18\x04\x20\x01(\x0b2\x06.AssetR\x05image\"b\n\
    \x07Mention\x12\x14\n\x05start\x18\x01\x20\x02(\x05R\x05start\x12\x16\n\
    \x06length\x18\x02\x20\x02(\x05R\x06length\x12\x19\n\x07user_id\x18\x03\
    \x20\x01(\tH\0R\x06userIdB\x0e\n\x0cmention_type\"c\n\x08LastRead\x12'\n\
    \x0fconversation_id\x18\x01\x20\x02(\tR\x0econversationId\x12.\n\x13last\
    _read_timestamp\x18\x02\x20\x02(\x03R\x11lastReadTimestamp\"_\n\x07Clear\
    ed\x12'\n\x0fconversation_id\x18\x01\x20\x02(\tR\x0econversationId\x12+\
    \n\x11cleared_timestamp\x18\x02\x20\x02(\x03R\x10clearedTimestamp\"U\n\
    \x0bMessageHide\x12'\n\x0fconversation_id\x18\x01\x20\x02(\tR\x0econvers\
    ationId\x12\x1d\n\nmessage_id\x18\x02\x20\x02(\tR\tmessageId\".\n\rMessa\
    geDelete\x12\x1d\n\nmessage_id\x18\x01\x20\x02(\tR\tmessageId\"g\n\x0bMe\
    ssageEdit\x120\n\x14replacing_message_id\x18\x01\x20\x02(\tR\x12replacin\
    gMessageId\x12\x1b\n\x04text\x18\x02\x20\x01(\x0b2\x05.TextH\0R\x04textB\
    \t\n\x07content\"g\n\x05Quote\x12*\n\x11quoted_message_id\x18\x01\x20\
    \x02(\tR\x0fquotedMessageId\x122\n\x15quoted_message_sha256\x18\x02\x20\
    \x01(\x0cR\x13quotedMessageSha256\"\xab\x01\n\x0cConfirmation\x12&\n\x04\
    type\x18\x02\x20\x02(\x0e2\x12.Confirmation.TypeR\x04type\x12(\n\x10firs\
    t_message_id\x18\x01\x20\x02(\tR\x0efirstMessageId\x12(\n\x10more_messag\
    e_ids\x18\x03\x20\x03(\tR\x0emoreMessageIds\"\x1f\n\x04Type\x12\r\n\tDEL\
    IVERED\x10\0\x12\x08\n\x04READ\x10\x01\"\xf6\x01\n\x08Location\x12\x1c\n\
    \tlongitude\x18\x01\x20\x02(\x02R\tlongitude\x12\x1a\n\x08latitude\x18\
    \x02\x20\x02(\x02R\x08latitude\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04\
    name\x12\x12\n\x04zoom\x18\x04\x20\x01(\x05R\x04zoom\x12A\n\x19expects_r\
    ead_confirmation\x18\x05\x20\x01(\x08:\x05falseR\x17expectsReadConfirmat\
    ion\x12E\n\x11legal_hold_status\x18\x06\x20\x01(\x0e2\x10.LegalHoldStatu\
    s:\x07UNKNOWNR\x0flegalHoldStatus\"\xa9\x02\n\nImageAsset\x12\x10\n\x03t\
    ag\x18\x01\x20\x02(\tR\x03tag\x12\x14\n\x05width\x18\x02\x20\x02(\x05R\
    \x05width\x12\x16\n\x06height\x18\x03\x20\x02(\x05R\x06height\x12%\n\x0e\
    original_width\x18\x04\x20\x02(\x05R\roriginalWidth\x12'\n\x0foriginal_h\
    eight\x18\x05\x20\x02(\x05R\x0eoriginalHeight\x12\x1b\n\tmime_type\x18\
    \x06\x20\x02(\tR\x08mimeType\x12\x12\n\x04size\x18\x07\x20\x02(\x05R\x04\
    size\x12\x17\n\x07otr_key\x18\x08\x20\x01(\x0cR\x06otrKey\x12\x17\n\x07m\
    ac_key\x18\t\x20\x01(\x0cR\x06macKey\x12\x10\n\x03mac\x18\n\x20\x01(\x0c\
    R\x03mac\x12\x16\n\x06sha256\x18\x0b\x20\x01(\x0cR\x06sha256\"\xa4\n\n\
    \x05Asset\x12+\n\x08original\x18\x01\x20\x01(\x0b2\x0f.Asset.OriginalR\
    \x08original\x127\n\x0cnot_uploaded\x18\x03\x20\x01(\x0e2\x12.Asset.NotU\
    ploadedH\0R\x0bnotUploaded\x12/\n\x08uploaded\x18\x04\x20\x01(\x0b2\x11.\
    Asset.RemoteDataH\0R\x08uploaded\x12(\n\x07preview\x18\x05\x20\x01(\x0b2\
    \x0e.Asset.PreviewR\x07preview\x12A\n\x19expects_read_confirmation\x18\
    \x06\x20\x01(\x08:\x05falseR\x17expectsReadConfirmation\x12E\n\x11legal_\
    hold_status\x18\x07\x20\x01(\x0e2\x10.LegalHoldStatus:\x07UNKNOWNR\x0fle\
    galHoldStatus\x1a\x98\x02\n\x08Original\x12\x1b\n\tmime_type\x18\x01\x20\
    \x02(\tR\x08mimeType\x12\x12\n\x04size\x18\x02\x20\x02(\x04R\x04size\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12,\n\x05image\x18\x04\x20\
    \x01(\x0b2\x14.Asset.ImageMetaDataH\0R\x05image\x12,\n\x05video\x18\x05\
    \x20\x01(\x0b2\x14.Asset.VideoMetaDataH\0R\x05video\x12,\n\x05audio\x18\
    \x06\x20\x01(\x0b2\x14.Asset.AudioMetaDataH\0R\x05audio\x12\x16\n\x06sou\
    rce\x18\x07\x20\x01(\tR\x06source\x12\x18\n\x07caption\x18\x08\x20\x01(\
    \tR\x07captionB\x0b\n\tmeta_data\x1a\xa0\x01\n\x07Preview\x12\x1b\n\tmim\
    e_type\x18\x01\x20\x02(\tR\x08mimeType\x12\x12\n\x04size\x18\x02\x20\x02\
    (\x04R\x04size\x12)\n\x06remote\x18\x03\x20\x01(\x0b2\x11.Asset.RemoteDa\
    taR\x06remote\x12,\n\x05image\x18\x04\x20\x01(\x0b2\x14.Asset.ImageMetaD\
    ataH\0R\x05imageB\x0b\n\tmeta_data\x1aO\n\rImageMetaData\x12\x14\n\x05wi\
    dth\x18\x01\x20\x02(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x02(\
    \x05R\x06height\x12\x10\n\x03tag\x18\x03\x20\x01(\tR\x03tag\x1ak\n\rVide\
    oMetaData\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\x12\x16\n\
    \x06height\x18\x02\x20\x01(\x05R\x06height\x12,\n\x12duration_in_millis\
    \x18\x03\x20\x01(\x04R\x10durationInMillis\x1an\n\rAudioMetaData\x12,\n\
    \x12duration_in_millis\x18\x01\x20\x01(\x04R\x10durationInMillis\x12/\n\
    \x13normalized_loudness\x18\x03\x20\x01(\x0cR\x12normalizedLoudness\x1a\
    \xaf\x01\n\nRemoteData\x12\x17\n\x07otr_key\x18\x01\x20\x02(\x0cR\x06otr\
    Key\x12\x16\n\x06sha256\x18\x02\x20\x02(\x0cR\x06sha256\x12\x19\n\x08ass\
    et_id\x18\x03\x20\x01(\tR\x07assetId\x12\x1f\n\x0basset_token\x18\x05\
    \x20\x01(\tR\nassetToken\x124\n\nencryption\x18\x06\x20\x01(\x0e2\x14.En\
    cryptionAlgorithmR\nencryption\"(\n\x0bNotUploaded\x12\r\n\tCANCELLED\
    \x10\0\x12\n\n\x06FAILED\x10\x01B\x08\n\x06status\"q\n\x08External\x12\
    \x17\n\x07otr_key\x18\x01\x20\x02(\x0cR\x06otrKey\x12\x16\n\x06sha256\
    \x18\x02\x20\x01(\x0cR\x06sha256\x124\n\nencryption\x18\x03\x20\x01(\x0e\
    2\x14.EncryptionAlgorithmR\nencryption\"\x86\x01\n\x08Reaction\x12\x14\n\
    \x05emoji\x18\x01\x20\x01(\tR\x05emoji\x12\x1d\n\nmessage_id\x18\x02\x20\
    \x02(\tR\tmessageId\x12E\n\x11legal_hold_status\x18\x03\x20\x01(\x0e2\
    \x10.LegalHoldStatus:\x07UNKNOWNR\x0flegalHoldStatus\"#\n\x07Calling\x12\
    \x18\n\x07content\x18\x01\x20\x02(\tR\x07content*!\n\x0cClientAction\x12\
    \x11\n\rRESET_SESSION\x10\0*/\n\x13EncryptionAlgorithm\x12\x0b\n\x07AES_\
    CBC\x10\0\x12\x0b\n\x07AES_GCM\x10\x01*9\n\x0fLegalHoldStatus\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\x0c\n\x08DISABLED\x10\x01\x12\x0b\n\x07ENABLED\x10\
    \x02B\x0f\n\rcom.waz.model\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
